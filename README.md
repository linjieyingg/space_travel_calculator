# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 22

**Last Updated:** 2025-11-18 22:43:13

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

This module `celestial_data.py` acts as a central repository for astrophysical data on solar system bodies within the `space_travel_calculator` application. It stores detailed parameters for celestial bodies and provides functions to retrieve this data and list potential travel destinations.

### Key Components:

*   **`GRAVITATIONAL_CONSTANT` and `SPEED_OF_LIGHT`**:
    *   **Description**: Universal physical constants re-exported for convenience and consistency.
    *   **Inputs**: None (directly imported from `constants`).
    *   **Outputs**: Constant values.
*   **`CELESTIAL_BODIES_DATA`**:
    *   **Description**: A dictionary containing detailed astrophysical parameters (mass, radius, gravitational parameter, semi-major axis from Sun, average distance from Earth for Moon) for various celestial bodies in the solar system.
    *   **Inputs**: None (static data definition).
    *   **Outputs**: Structured data for celestial bodies.
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Description**: Retrieves the astrophysical data for a specified celestial body.
    *   **Inputs**: `body_name` (string, case-insensitive name of the celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Description**: Generates a sorted list of potential solar system destinations from Earth, including their names and calculated distances.
    *   **Inputs**: None (uses the internal `CELESTIAL_BODIES_DATA`).
    *   **Outputs**: A list of dictionaries, each with a 'name' and 'distance' (from Earth) in meters, sorted by distance. Returns `None` if Earth's data is unavailable.

### Dependencies:

*   **`math`**: Used for `fabs()` in distance calculations.
*   **`constants`**: Provides `G_GRAVITATIONAL` and `C_LIGHT_MPS` universal physical constants.

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## fuel_optimizer.py

### 1. Purpose
This file orchestrates the calculation of optimal fuel mass required for a spacecraft's trajectory. It integrates a trajectory planner to determine the necessary delta-V and then uses a propulsion system model to compute the fuel mass based on that delta-V and engine parameters.

### 2. Key Components
*   **`optimize_fuel_for_trajectory` function**:
    *   **Inputs**:
        *   `start_body` (str): Origin celestial body.
        *   `end_body` (str): Target celestial body.
        *   `trajectory_type` (str): The type of trajectory (currently only 'Hohmann' supported).
        *   `spacecraft_dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `engine_specific_impulse` (float): Engine's specific impulse (seconds).
        *   `**trajectory_args`: Additional keyword arguments passed to the trajectory planner (e.g., `launch_date`).
    *   **Outputs**:
        *   `float`: The calculated optimal fuel mass in kilograms.
    *   **Side Effects**:
        *   Raises `ValueError` for invalid inputs or calculation issues.
        *   Raises `RuntimeError` for unexpected errors during planning or calculation.
        *   Raises `ImportError` if critical dependencies are missing.
*   **Internal Logic**:
    *   Instantiates `TrajectoryPlanner`.
    *   Calls `planner.plan_trajectory` to get `total_delta_v`.
    *   Calls `calculate_fuel_mass_from_delta_v` (from `propulsion_system`) to compute fuel mass.

### 3. Dependencies
*   **`math`**: Standard Python mathematical functions (imported, though not explicitly used within this file's direct logic).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`).
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

This `main.py` file implements a space travel calculator that determines the time, fuel requirements, and cost for a user to reach a chosen celestial destination, incorporating relativistic effects. It guides the user through input collection, performs complex calculations using various modules, and presents a comprehensive travel summary.

### Key Components:

*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**
    *   **Inputs**: Travel time in the traveler's frame (years) and average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years), accounting for relativistic time dilation, or traveler's time if speed is invalid.
*   **`calc_age(years_travel_time, starting_age)`**
    *   **Inputs**: Total travel time (years) and the user's starting age (int).
    *   **Outputs**: The user's calculated age upon arrival (float).
*   **`calc_arrival(departure_date, years_earth_frame)`**
    *   **Inputs**: Departure date (`datetime`) and total travel time in Earth's frame (years).
    *   **Outputs**: Estimated arrival date (`datetime`) or `None` if calculation fails due to extreme duration or invalid inputs.
*   **`convert_date(date_str)`**
    *   **Inputs**: A date string in 'YYYY-MM-DD' format.
    *   **Outputs**: A `datetime` object representing the parsed date.
*   **`main()` function**
    *   **Inputs**: Interactive user inputs for departure/arrival bodies, spacecraft dry mass, engine specific impulse, departure date, user age, and fuel price per unit.
    *   **Outputs/Side Effects**: Prints a welcome message, lists destinations, displays a detailed travel summary (including delta-V, fuel mass/cost, travel times, arrival age, and date), and logs travel details via `travel_logger`. It orchestrates calls to various modules for trajectory planning, fuel optimization, and calculation of relativistic effects.
*   **`TrajectoryPlanner` (from `trajectory_planner`)**
    *   **Inputs**: Departure/arrival body names, trajectory type (e.g., 'Hohmann').
    *   **Outputs**: A dictionary containing `total_delta_v_mps`, `total_travel_time_seconds`, `transfer_type`, and `average_hohmann_speed_ms`.
*   **`fuel_optimizer.optimize_fuel_for_trajectory` (from `fuel_optimizer`)**
    *   **Inputs**: Start/end bodies, trajectory type, spacecraft dry mass, engine specific impulse.
    *   **Outputs**: The calculated total fuel mass needed (kg).
*   **`fuel_calc.calculate_fuel_cost` (from `fuel_calc`)**
    *   **Inputs**: Total fuel mass needed and fuel price per unit mass.
    *   **Outputs**: A dictionary containing the `total_cost`.
*   **`travel_logger.save_travel_log` (from `travel_logger`)**
    *   **Inputs**: Source/destination planets, speed, travel time, delta-V, fuel mass, and transfer type.
    *   **Side Effects**: Saves the provided travel details to a log file.

### Dependencies:

*   **Standard Library**: `math`, `datetime` (`datetime`, `timedelta`)
*   **Local Modules**: `checks`, `celestial_data`, `orbital_mechanics`, `trajectory_planner`, `propulsion_system`, `fuel_calc`, `travel_logger`, `constants`, `fuel_optimizer`.

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_fuel_optimizer.py`

This file contains unit tests for the `optimize_fuel_for_trajectory` function within the `fuel_optimizer` module, using `pytest` for testing and `unittest.mock` for dependency mocking.

### Purpose
The purpose of this file is to thoroughly test the `optimize_fuel_for_trajectory` function, verifying its correct behavior under various conditions, including successful execution, invalid inputs, and error propagation from its dependencies (`TrajectoryPlanner` and a fuel calculation function from `propulsion_system`).

### Key Components

*   **`mock_dependencies_for_fuel_optimizer` (pytest fixture)**
    *   **Inputs**: None (a pytest fixture).
    *   **Outputs**: A dictionary containing mocked instances of `TrajectoryPlanner` and the `calculate_fuel_mass_from_delta_v` function (aliased in `fuel_optimizer`), pre-configured with default successful return values.
    *   **Side Effects**: Patches `fuel_optimizer.TrajectoryPlanner` and `fuel_optimizer.calculate_fuel_mass_from_delta_v` using `unittest.mock.patch`.
*   **`test_optimize_fuel_for_trajectory_success`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that `optimize_fuel_for_trajectory` returns the expected fuel mass and that its internal dependencies (`TrajectoryPlanner.plan_trajectory` and the fuel mass calculation) were called exactly once with the correct arguments.
*   **`test_optimize_fuel_for_trajectory_unsupported_trajectory_type`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised when an unsupported trajectory type is provided, and that no mocked dependencies were called.
*   **`test_optimize_fuel_for_trajectory_invalid_inputs` (parameterized)**
    *   **Inputs**: `dry_mass`, `specific_impulse`, `expected_error` (from `pytest.mark.parametrize`).
    *   **Outputs**: Asserts that a `ValueError` is raised for various invalid inputs (e.g., non-positive dry mass or specific impulse, non-numeric values).
*   **`test_optimize_fuel_for_trajectory_planner_returns_unsuccessful`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a failure status.
*   **`test_optimize_fuel_for_trajectory_planner_returns_invalid_delta_v`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a negative `total_delta_v`.
*   **`test_optimize_fuel_for_trajectory_propulsion_system_raises_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (wrapped) is raised if the mocked fuel calculation function itself raises an error.
*   **`test_optimize_fuel_for_trajectory_propulsion_returns_negative_fuel`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if the mocked fuel calculation function returns a negative fuel mass.
*   **`test_optimize_fuel_for_trajectory_planner_raises_runtime_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `RuntimeError` (wrapped) is raised if `TrajectoryPlanner.plan_trajectory` raises an unexpected `RuntimeError`.
*   **`test_optimize_fuel_for_trajectory_planner_raises_type_error_with_kwargs`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (indicating a signature mismatch) is raised if `TrajectoryPlanner.plan_trajectory` raises a `TypeError`, such as from receiving unexpected keyword arguments.

### Dependencies

*   `pytest`: Test framework.
*   `unittest.mock.MagicMock`: For creating mock objects.
*   `unittest.mock.patch`: For temporarily replacing objects with mocks.
*   `fuel_optimizer`: The module under test, specifically importing `optimize_fuel_for_trajectory` and `TrajectoryPlanner`.

---


## `tests/test_main.py`

This file, `tests/test_main.py`, is a comprehensive Pytest suite designed to test the `main.py` application. Its primary purpose is to verify the correct integration of various modules within `main.py` and ensure robust error handling under different failure scenarios, as well as to test specific helper functions.

### Key Components

*   **`mock_dependencies` (Pytest Fixture)**:
    *   **Inputs**: None directly, but it patches numerous functions and classes from `main.py`'s dependencies (`celestial_data`, `trajectory_planner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `builtins.input`, `builtins.print`, `main.c`).
    *   **Outputs/Side Effects**: Yields a dictionary of configured mock objects, allowing test functions to interact with and assert calls on these mocks. It sets up `side_effect` and `return_value` for various mocked functions to simulate different system behaviors.
*   **`test_main_function_integrates_all_components_correctly` (Test Function)**:
    *   **Inputs**: Uses the `mock_dependencies` fixture and simulates user input via `mock_input`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that all mocked external functions are called with expected arguments, and that `main.main()` produces the correct output messages via `mock_print` and logs travel details via `mock_save_travel_log`. It specifically checks relativistic time calculations, estimated arrival dates, and age calculations.
*   **Error Handling Test Functions (e.g., `test_main_function_trajectory_planner_fails`, `test_main_function_fuel_optimizer_raises_value_error`)**:
    *   **Inputs**: Use `mock_dependencies` and `mock_input`, but configure specific mocks to simulate failures (e.g., `return_value={'success': False}` or `side_effect=ValueError`).
    *   **Outputs/Side Effects**: Call `main.main()` and assert that appropriate error messages are printed via `mock_print`, and that subsequent processing steps (like fuel optimization or logging) are not called.
*   **Helper Function Test Cases (e.g., `test_calc_time_earth_relativistic_zero_speed`, `test_calc_age_valid_inputs`, `test_calc_arrival_valid_inputs`, `test_convert_date_valid`)**:
    *   **Inputs**: Direct arguments to `main.calc_time_earth`, `main.calc_age`, `main.calc_arrival`, `main.convert_date`.
    *   **Outputs/Side Effects**: Assert the correctness of the return values for various valid and edge-case inputs, including checking for specific warnings printed and `ValueError` exceptions raised for invalid inputs.
*   **`test_main_function_average_speed_fallback` (Test Function)**:
    *   **Inputs**: Uses `mock_dependencies` and `mock_input`, specifically mocking a zero `average_hohmann_speed_ms`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that a warning is printed regarding the fallback speed, and that `mock_save_travel_log` is called with the expected fallback speed (0.1% of C).

### Dependencies

*   `pytest`: For the testing framework and fixtures.
*   `unittest.mock.patch`, `MagicMock`, `call`: For mocking external dependencies and internal functions.
*   `datetime.datetime`, `timedelta`: For date and time calculations and assertions.
*   `math`: For mathematical operations like `sqrt` in relativistic calculations.
*   `sys`: Imported but not directly used in the provided snippet.
*   `main`: The module under test.
*   `constants.C_LIGHT_MPS`: A specific constant used in relativistic calculations.

---


## `tests/test_trajectory_planner.py`

```markdown
### Purpose
This file contains unit tests for the `TrajectoryPlanner` class, specifically covering its initialization and the `plan_trajectory` method for Hohmann transfers. It validates successful operations, input handling, error conditions, and interactions with mocked external data and orbital mechanics calculations.

### Key Components
*   **`mock_celestial_data_for_planner` (pytest fixture)**:
    *   **Inputs**: A celestial body name (string) when `celestial_data.get_celestial_body_data` is called.
    *   **Outputs/Side Effects**: Mocks the `get_celestial_body_data` function to return predefined celestial body data (Sun, Earth, Mars, Jupiter) or `None` for unknown names.
*   **`mock_orbital_mechanics` (pytest fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Mocks `orbital_mechanics.calculate_hohmann_transfer_delta_v` to return a fixed `(delta_v1, delta_v2, total_delta_v)` tuple, and `orbital_mechanics.calculate_hohmann_transfer_time_of_flight` to return a fixed time in seconds.
*   **Tests for `TrajectoryPlanner.__init__`**:
    *   **Inputs**: Implicitly creates `TrajectoryPlanner` instances, relying on `mock_celestial_data_for_planner` to provide Sun data.
    *   **Outputs/Side Effects**: Asserts correct `mu_sun` value upon successful initialization or verifies that `ValueError`/`AttributeError` are raised for invalid or missing Sun data.
*   **Tests for `TrajectoryPlanner.plan_trajectory` (Hohmann type)**:
    *   **Inputs**: Calls `planner.plan_trajectory(departure_body, arrival_body, trajectory_type="Hohmann")` with various combinations of valid and invalid body names and data. Utilizes `mock_celestial_data_for_planner` and `mock_orbital_mechanics`.
    *   **Outputs/Side Effects**: Asserts the structure and content of the returned `result` dictionary (success status, delta-v, travel time, error messages) and verifies correct calls to mocked orbital mechanics functions. Includes tests for input validation, missing/invalid celestial data, and error propagation from orbital calculations.
*   **New Tests for `TrajectoryPlanner.plan_trajectory` specific dispatching and error handling**:
    *   **Inputs**: Calls `planner.plan_trajectory` with no `trajectory_type` (to test defaulting) or with unsupported/invalid `trajectory_type` arguments.
    *   **Outputs/Side Effects**: Confirms that Hohmann transfer is used by default and that appropriate error messages are returned for unsupported or non-string trajectory types.

### Dependencies
*   `pytest`
*   `unittest.mock.patch`
*   `unittest.mock.MagicMock`
*   `datetime.timedelta`
*   `math`
*   `trajectory_planner` (the main module under test)
*   `celestial_data` (mocked via `patch`)
*   `orbital_mechanics` (mocked via `patch`)
*   `constants` (imported, but not directly used in the test logic, likely for `trajectory_planner` itself)
```

---


## `trajectory_planner.py`

This file defines a `TrajectoryPlanner` class that provides a high-level interface for calculating interplanetary transfer trajectories, primarily Hohmann transfers. It orchestrates calls to underlying orbital mechanics functions and celestial data to determine parameters like total delta-v and travel time for a given departure and arrival body.

### Key Components:

*   **Class: `TrajectoryPlanner`**
    *   **`__init__(self)`**
        *   **Inputs**: None.
        *   **Outputs/Side Effects**: Initializes the planner by fetching the Sun's gravitational parameter (`mu_sun`) from `celestial_data`. Raises `ValueError` or `AttributeError` if Sun data is missing or invalid.
    *   **`_plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str) -> dict`**
        *   **Inputs**: `departure_body_name` (string) and `arrival_body_name` (string) representing celestial bodies.
        *   **Outputs/Side Effects**: Returns a dictionary containing comprehensive details of a Hohmann transfer, including total delta-v (m/s), travel time (days and formatted string), and success status with an error message if applicable. It retrieves body data from `celestial_data` and uses `orbital_mechanics` for calculations.
    *   **`plan_trajectory(self, departure_body_name: str, arrival_body_name: str, trajectory_type: str = 'Hohmann', **kwargs) -> dict`**
        *   **Inputs**: `departure_body_name` (string), `arrival_body_name` (string), `trajectory_type` (string, defaults to 'Hohmann'), and optional `kwargs`.
        *   **Outputs/Side Effects**: Acts as a dispatcher. Currently supports only 'Hohmann' transfers by calling `_plan_hohmann_trajectory`. Returns a dictionary with trajectory details or an error message for unsupported types or failed validation.
*   **`if __name__ == '__main__':` block**
    *   **Purpose**: Contains example usage of the `TrajectoryPlanner` class, demonstrating how to plan various valid and invalid Hohmann transfer trajectories and print their results or error messages.

### Dependencies:

*   `math` (standard library)
*   `datetime.timedelta` (standard library)
*   `orbital_mechanics` (custom module)
*   `celestial_data` (custom module)
*   `constants.G_GRAVITATIONAL` (custom module, imported but not used in the provided code)

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
