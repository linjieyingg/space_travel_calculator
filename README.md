# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 21

**Last Updated:** 2026-02-10 16:29:19

---


## `celestial_data.py`

This module `celestial_data.py` acts as a central repository for astrophysical data and orbital elements for celestial bodies within the solar system, intended for the `space_travel_calculator` application. It also re-exports universal physical constants for consistent use across the application.

### Key Components

*   **Constants**:
    *   `GRAVITATIONAL_CONSTANT`: Re-exports the gravitational constant from the `constants` module.
    *   `SPEED_OF_LIGHT`: Re-exports the speed of light from the `constants` module.
    *   `AU_TO_METERS`: Defines the conversion factor from Astronomical Units to meters.
*   **`CELESTIAL_BODIES_DATA`**:
    *   A dictionary that stores comprehensive astrophysical parameters (mass, radius, gravitational parameter, semi-major axis, orbital period, eccentricity, inclination, longitude of ascending node, argument of periapsis, and mean anomaly at J2000 epoch) for various celestial bodies including the Sun, planets, and Earth's Moon.
    *   **Inputs**: Accessed by uppercase string keys representing celestial body names (e.g., "EARTH").
    *   **Outputs**: Returns a dictionary containing all defined parameters for the specified body.
*   **`get_celestial_body_data(body_name: str)`**:
    *   A function to retrieve the data for a specific celestial body.
    *   **Inputs**: `body_name` (a case-insensitive string representing the name of the celestial body).
    *   **Outputs**: Returns a dictionary of the requested body's data if found, otherwise `None`.

### Dependencies

*   `math`: Imported (specifically for `fabs()`, though not explicitly used in the provided snippet).
*   `constants`: Imports `G_GRAVITATIONAL` and `C_LIGHT_MPS`.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants crucial for space travel calculations within the `space_travel_calculator` application, ensuring data consistency and maintainability.

### Key Components:

*   **Universal Physical Constants**:
    *   `C_LIGHT_MPS`: Represents the speed of light in a vacuum.
        *   **Value**: `299792458.0` m/s.
    *   `G_GRAVITATIONAL`: Represents the Gravitational Constant.
        *   **Value**: `6.67430e-11` m^3 kg^-1 s^-2.
*   **Aliases**:
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`, providing backward compatibility for modules expecting this specific name.
        *   **Value**: Same as `G_GRAVITATIONAL`.
*   **Commented-out Examples**:
    *   Includes examples like `MU_SUN` (Sun's standard gravitational parameter), `AU_TO_METERS` (Astronomical Unit in meters), and `EARTH_RADIUS_METERS` (Average Earth radius) as placeholders for future expansion.

### Dependencies:

*   This file has no external imports or dependencies.

---


## `generated/2048_game.py`

This Python file implements the classic 2048 puzzle game, allowing a player to interactively play the game in the console.

### Key Components:

*   **`Game2048` Class**: Manages the entire game state and logic.
    *   **`__init__(self)`**:
        *   **Inputs**: None.
        *   **Outputs/Side Effects**: Initializes a 4x4 grid with two random tiles, sets initial score to 0, and `won`/`game_over` flags to `False`.
    *   **`add_random_tile(self)`**:
        *   **Inputs**: None.
        *   **Outputs/Side Effects**: Finds an empty cell and places a '2' (90% chance) or '4' (10% chance) into it. Returns `True` if a tile was added, `False` otherwise.
    *   **`display_board(self)`**:
        *   **Inputs**: None.
        *   **Outputs/Side Effects**: Clears the console and prints the current game board and score in a formatted way.
    *   **`_get_row_view(self, r)` / `_set_row_view(self, r, new_row)`**:
        *   **Inputs**: `r` (row index), `new_row` (list of integers).
        *   **Outputs/Side Effects**: Get or set a specific row of the grid.
    *   **`_get_col_view(self, c)` / `_set_col_view(self, c, new_col)`**:
        *   **Inputs**: `c` (column index), `new_col` (list of integers).
        *   **Outputs/Side Effects**: Get or set a specific column of the grid.
    *   **`_shift_and_merge(self, line)`**:
        *   **Inputs**: `line` (a list of 4 integers representing a row or column).
        *   **Outputs**: `final_line` (the processed list after shifting and merging), `changed` (boolean indicating if the line changed).
        *   **Side Effects**: Updates `self.score` and sets `self.won` to `True` if 2048 is reached. This is the core logic for combining tiles.
    *   **`move(self, direction)`**:
        *   **Inputs**: `direction` (string: 'up', 'down', 'left', 'right').
        *   **Outputs**: `moved_happened` (boolean indicating if any tiles moved or merged).
        *   **Side Effects**: Applies `_shift_and_merge` to all relevant rows/columns based on direction, updates the grid, calls `add_random_tile` if a move occurred, and calls `check_game_over`.
    *   **`check_game_over(self)`**:
        *   **Inputs**: None.
        *   **Outputs**: Boolean (`True` if the game is over, `False` otherwise).
        *   **Side Effects**: Updates `self.game_over` flag based on whether there are empty cells or possible merges.

*   **`play_2048()` Function**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Runs the main game loop, handles user input for moves ('w', 'a', 's', 'd', 'q'), displays the board, and prints game-over or win messages.

### Dependencies:

*   **`random`**: Used for generating random tile values (2 or 4) and placing them in random empty cells.
*   **`os`**: Used for clearing the console screen to refresh the game board display.

---


## `generated/change_four_to_five_in_a_row.py`

## Summary of `generated/change_four_to_five_in_a_row.py`

This file provides a utility function to update textual references related to game titles or descriptions. It specifically changes instances of "four in a row" to "five in a row".

### Key Components

*   **Function**: `update_game_reference`
    *   **Inputs**: `text` (a string) - The input text to be processed.
    *   **Outputs**: A string where all occurrences of "four in a row" have been replaced by "five in a row".

### Dependencies

*   None. This file uses only built-in Python string methods.

---


## `generated/count_vowels.py`

### Summary of `generated/count_vowels.py`

This file defines a single Python function designed to count the occurrences of vowels in a given string. It provides a simple, case-insensitive way to determine the total number of 'a', 'e', 'i', 'o', 'u' characters.

### Key Components

*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The input string to be analyzed.
    *   **Outputs**: An `int` representing the total count of vowels found in the string.

### Dependencies

*   None. This file uses only built-in Python features and has no external imports or dependencies.

---


## `generated/four_in_a_row.py`

```markdown
## File Analysis: `generated/four_in_a_row.py`

### Purpose
This Python file implements a command-line based Four-in-a-Row (also known as Connect Four) game. It allows two players to take turns dropping pieces into a grid, aiming to get four of their pieces in a row, column, or diagonal.

### Key Components
*   **`create_board()`**
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Returns a 2D list representing the game board, initialized with 0s for empty slots.
*   **`print_board(board)`**
    *   **Inputs**: `board` (a 2D list representing the current game state).
    *   **Outputs/Side Effects**: Prints a formatted visual representation of the game board to the console, using 'X' for Player 1 and 'O' for Player 2.
*   **`is_valid_location(board, col)`**
    *   **Inputs**: `board` (2D list), `col` (integer column index).
    *   **Outputs/Side Effects**: Returns `True` if the specified column is within bounds and has an empty slot; otherwise, returns `False`.
*   **`get_next_open_row(board, col)`**
    *   **Inputs**: `board` (2D list), `col` (integer column index).
    *   **Outputs/Side Effects**: Returns the 0-indexed row number of the lowest empty slot in the given column.
*   **`drop_piece(board, row, col, piece)`**
    *   **Inputs**: `board` (2D list), `row` (integer row index), `col` (integer column index), `piece` (player identifier, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing the `piece` at the specified `row` and `col`.
*   **`winning_move(board, piece)`**
    *   **Inputs**: `board` (2D list), `piece` (player identifier).
    *   **Outputs/Side Effects**: Returns `True` if the specified `piece` has achieved four consecutive pieces horizontally, vertically, or diagonally; otherwise, returns `False`.
*   **`is_board_full(board)`**
    *   **Inputs**: `board` (2D list).
    *   **Outputs/Side Effects**: Returns `True` if the entire board is filled with pieces (indicating a potential tie); otherwise, returns `False`.
*   **`four_in_a_row_game()`**
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game flow, including initializing the board, handling player turns, validating input, dropping pieces, checking for wins or ties, and printing game status.

### Dependencies
*   **`sys`**: Used for `sys.stdout.flush()` to ensure immediate display of printed output.
```

---


## `generated/tictactoe.py`

```markdown
1.  **Purpose**: This file implements a command-line Tic-Tac-Toe game, allowing two human players (X and O) to take turns marking spaces on a 3x3 board until a win condition is met or the game ends in a draw.

2.  **Key Components**:
    *   `play_tic_tac_toe()`:
        *   Inputs: None.
        *   Outputs or Side Effects: Orchestrates the entire game. It initializes the board, randomly selects the starting player, manages player turns, takes user input for moves, calls helper functions to display the board and check game state, and prints game status (win/draw) and the final game over message to the console.
    *   `display_board(current_board)`:
        *   Inputs: `current_board` (a list of 9 strings representing the board's state).
        *   Outputs or Side Effects: Prints a formatted 3x3 Tic-Tac-Toe board to the console.
    *   `check_win(current_board, player)`:
        *   Inputs: `current_board` (a list of 9 strings), `player` (the symbol 'X' or 'O' to check for a win).
        *   Outputs: Returns `True` if the specified `player` has three of their marks in a row (horizontal, vertical, or diagonal), `False` otherwise.
    *   `check_draw(current_board)`:
        *   Inputs: `current_board` (a list of 9 strings).
        *   Outputs: Returns `True` if there are no empty spaces (' ') left on the board, indicating a draw, `False` otherwise.

3.  **Dependencies**:
    *   `random`: Used to randomly select which player starts the game.
```

---


## `main.py`

This file serves as the main entry point for a space travel calculator application, handling initial user authentication before presenting the main application features.

### Key Components

*   **`display_auth_menu()`**
    *   **Inputs**: None (takes user input via `input()`).
    *   **Outputs/Side Effects**: Prints an authentication menu, prompts the user for choice, calls `register_user` or `login_user`, and returns `True` if a user successfully logs in, `False` otherwise. It continuously loops until a valid action (login or exit) is chosen.
*   **`main()`**
    *   **Inputs**: None (orchestrates application flow and takes user input via `input()`).
    *   **Outputs/Side Effects**: Prints welcome messages, calls `display_auth_menu`, and if authentication is successful, displays a main application menu allowing the user to `Plan a Space Trip` (by calling `interactive_trip_planner`) or exit. It controls the primary execution flow of the application.
*   **`if __name__ == "__main__":` block**
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Calls the `main()` function, initiating the application when the script is run directly.

### Dependencies

*   `src.user_management.auth.register_user`
*   `src.user_management.auth.login_user`
*   `src.trip_planning.space_trip_planner.interactive_trip_planner`

---


## `src/__init__.py`

*Empty file*

---


## `src/astrophysics/__init__.py`

*Empty file*

---


## `src/astrophysics/orbital_calculations.py`

This Python file provides a collection of functions for performing fundamental orbital calculations and astrodynamics maneuvers. It enables the determination of celestial body positions, velocities, escape velocities, orbital periods, and Hohmann transfer costs based on orbital mechanics principles and data retrieved from a separate celestial data module.

### Key Components:

*   **`solve_kepler_equation`**
    *   **Inputs**: Mean anomaly (`float`), eccentricity (`float`), optional tolerance (`float`), and max iterations (`int`).
    *   **Outputs**: The eccentric anomaly (`float`) in radians.
*   **`eccentric_to_true_anomaly`**
    *   **Inputs**: Eccentric anomaly (`float`), eccentricity (`float`).
    *   **Outputs**: The true anomaly (`float`) in radians.
*   **`calculate_orbital_distance`**
    *   **Inputs**: Celestial body name (`str`), time since periapsis (`float`).
    *   **Outputs**: The orbital distance (`Optional[float]`) from the central body in meters, or `None` if the body is not found.
*   **`calculate_orbital_velocity`**
    *   **Inputs**: Orbiting body name (`str`), current radial distance (`float`), optional central body name (`str`).
    *   **Outputs**: The instantaneous orbital velocity (`float`) in meters per second.
*   **`calculate_escape_velocity`**
    *   **Inputs**: Celestial body name (`str`), radial distance from its center (`float`).
    *   **Outputs**: The escape velocity (`float`) in meters per second.
*   **`calculate_orbital_period`**
    *   **Inputs**: Orbiting body name (`str`), optional central body name (`str`).
    *   **Outputs**: The orbital period (`float`) in seconds.
*   **`calculate_hohmann_delta_v`**
    *   **Inputs**: Initial body name (`str`), final body name (`str`), central body name (`str`).
    *   **Outputs**: A dictionary containing the magnitudes of the first delta-v impulse ('delta_v1'), the second delta-v impulse ('delta_v2'), and the total delta-v ('total_delta_v') for a Hohmann transfer, all in m/s.

### Dependencies:

*   `math`: For mathematical operations (e.g., `sin`, `cos`, `sqrt`, `atan2`, `fmod`, `pi`).
*   `typing`: Specifically `Dict`, `Any`, `Optional` for type hinting.
*   `..celestial_data`: A relative import for `get_celestial_body_data` and `GRAVITATIONAL_CONSTANT`, used to retrieve properties of celestial bodies.

---


## `src/data/__init__.py`

*Empty file*

---


## `src/propulsion/__init__.py`

*Empty file*

---


## `src/trip_planning/space_trip_planner.py`

## Summary of `space_trip_planner.py`

### Purpose
This file implements the `SpaceTripPlanner` class, providing core logic for planning Hohmann transfer space trips, calculating required delta-V and transfer times, and offering an interactive command-line interface for users to plan journeys between celestial bodies.

### Key Components
*   **Class `SpaceTripPlanner`**:
    *   **Inputs**: None on instantiation, but relies on global constants and functions from `celestial_data.py`.
    *   **Outputs/Side Effects**: Initializes the planner by loading the Sun's gravitational parameter, raising a `ValueError` if critical data is missing.

*   **`__init__(self)`**:
    *   **Inputs**: `self`.
    *   **Outputs/Side Effects**: Sets `_celestial_body_raw_data` and extracts `_mu_sun`. Raises `ValueError` if Sun's gravitational parameter is not found.

*   **`_get_body_orbital_radius_meters(self, body_name: str) -> Optional[float]`**:
    *   **Inputs**: `body_name` (string) - The name of a celestial body.
    *   **Outputs**: The semi-major axis (orbital radius) of the body in meters as a float, or `None` if data is not found.

*   **`_calculate_hohmann_transfer_time(self, r1: float, r2: float, mu_central: float) -> float`**:
    *   **Inputs**: `r1` (float) - Initial orbital radius; `r2` (float) - Final orbital radius; `mu_central` (float) - Gravitational parameter of the central body (e.g., Sun). All in meters/SI units.
    *   **Outputs**: The transfer time in seconds as a float. Raises `ValueError` for non-positive input values.

*   **`plan_trip(self, source_body_name: str, target_body_name: str) -> Optional[Dict[str, Any]]`**:
    *   **Inputs**: `source_body_name` (string) - Name of the departure body; `target_body_name` (string) - Name of the destination body.
    *   **Outputs**: A dictionary containing trip details (`delta_v1`, `delta_v2`, `total_delta_v`, `transfer_time_seconds/days/years`) or `None` if planning fails due to invalid inputs or data retrieval issues. Prints error messages to console.

*   **`display_trip_summary(self, trip_data: Dict[str, Any])`**:
    *   **Inputs**: `trip_data` (dictionary) - A dictionary containing trip details, typically from `plan_trip`.
    *   **Outputs/Side Effects**: Prints a formatted summary of the planned trip (Delta-V values, transfer time in hours, days, and years) to the console.

*   **`run_interactive_planner(self)`**:
    *   **Inputs**: None (interacts with the user via `input()`).
    *   **Outputs/Side Effects**: Provides a continuous command-line interface for planning trips, prompting for source and target bodies. Calls `plan_trip` and `display_trip_summary`. Prints welcome/farewell messages and error prompts.

*   **`_list_available_bodies(self)`**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Prints a sorted list of all celestial bodies present in the loaded `_celestial_body_raw_data`.

*   **Main execution block (`if __name__ == "__main__":`)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Instantiates `SpaceTripPlanner` and starts the interactive planner. Catches `ValueError` during initialization.

### Dependencies
*   `math`
*   `typing.Optional`, `typing.Dict`, `typing.Any`
*   `src.astrophysics.orbital_calculations.calculate_hohmann_delta_v` (relative import)
*   `celestial_data.get_celestial_body_data` (relative import)
*   `celestial_data.AU_TO_METERS` (relative import)
*   `celestial_data.CELESTIAL_BODIES_DATA` (relative import)

---


## `src/user_management/auth.py`

This Python file provides a basic user authentication system that allows for user registration and login using local file storage. It securely stores user credentials by hashing passwords with unique salts.

### Key Components:

*   **`_DATA_DIR`, `_USERS_FILE_PATH`**: Constants defining the location for the `users.json` data file.
*   **`_ensure_data_dir_exists()`**: Ensures the data directory exists.
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Creates the directory if it doesn't exist.
*   **`_load_users()`**: Loads user data from `users.json`.
    *   **Inputs**: None
    *   **Outputs**: A dictionary of user data (`Dict[str, Any]`), or an empty dictionary on error/file not found.
*   **`_save_users(users)`**: Saves user data to `users.json`.
    *   **Inputs**: `users` (A dictionary of user data `Dict[str, Any]`).
    *   **Outputs/Side Effects**: Writes the provided user data to `users.json`.
*   **`_generate_salt()`**: Generates a random hexadecimal salt.
    *   **Inputs**: None
    *   **Outputs**: A `str` representing the salt.
*   **`_hash_password(password, salt)`**: Hashes a given password with a salt using SHA256.
    *   **Inputs**: `password` (str), `salt` (str).
    *   **Outputs**: A `str` representing the SHA256 hash.
*   **`register_user(username, password)`**: Registers a new user.
    *   **Inputs**: `username` (str), `password` (str).
    *   **Outputs**: `bool` (`True` for successful registration, `False` if username exists or inputs are invalid).
    *   **Side Effects**: Adds new user data (username, password hash, salt) to `users.json`.
*   **`login_user(username, password)`**: Authenticates a user.
    *   **Inputs**: `username` (str), `password` (str).
    *   **Outputs**: `bool` (`True` for successful login, `False` otherwise).
*   **`if __name__ == "__main__":`**: Contains a test suite to demonstrate and verify the functionality of user registration and login.
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Prints test results to console, creates/removes `users.json` for testing.

### Dependencies:

*   `json`: For reading and writing user data in JSON format.
*   `hashlib`: For password hashing (SHA256).
*   `os`: For file path manipulation and directory creation/checking.
*   `typing`: For type hints (`Dict`, `Any`).

---


## `src/utils/__init__.py`

*Empty file*

---


## `tests/__init__.py`

*Empty file*

---


## `tests/test_celestial_data.py`

This file contains unit tests for the `celestial_data` module. It verifies the correctness of re-exported constants, the functionality and edge cases of data retrieval functions, and the structural integrity of the underlying celestial body data.

### Key Components:

*   **Test Constants Re-exported from celestial_data**:
    *   `test_gravitational_constant_re_export_value()`: Asserts that `GRAVITATIONAL_CONSTANT` from `celestial_data` matches `G_GRAVITATIONAL` from `constants`.
    *   `test_speed_of_light_re_export_value()`: Asserts that `SPEED_OF_LIGHT` from `celestial_data` matches `C_LIGHT_MPS` from `constants`.
    *   **Inputs**: Implicitly uses constants from `celestial_data` and `constants` modules.
    *   **Outputs**: Performs assertions for value and type equality.
*   **Test `get_celestial_body_data` function**:
    *   `test_get_celestial_body_data_valid_body()`: Tests data retrieval for a known body ('Earth'), checking dictionary structure, key presence, and value types.
    *   `test_get_celestial_body_data_case_insensitivity()`: Verifies that body names are handled case-insensitively.
    *   `test_get_celestial_body_data_non_existent_body()`: Asserts `None` is returned for unknown bodies.
    *   `test_get_celestial_body_data_invalid_input_type()`: Asserts `None` is returned for non-string inputs.
    *   `test_get_celestial_body_data_sun_orbital_elements_expected_values()`: Checks specific expected values for 'Sun' (e.g., zero semi-major axis).
    *   **Inputs**: String celestial body names or invalid types.
    *   **Outputs**: Assertions on the returned dictionary's content, type, or `None`.
*   **Test `get_all_solar_system_destinations` function**:
    *   `test_get_all_solar_system_destinations_valid_output()`: Checks that a sorted list of dictionaries (destinations, excluding Earth) is returned with correct structure and sorting.
    *   `test_get_all_solar_system_destinations_earth_data_missing()`: Uses `unittest.mock.patch` to simulate missing Earth data and asserts the function returns `None`.
    *   **Inputs**: None (implicitly calls `get_all_solar_system_destinations`). One test uses mocking to control internal function behavior.
    *   **Outputs**: Assertions on the returned list's content, order, and structure, or `None`.
*   **`test_celestial_bodies_data_integrity()`**:
    *   Performs a loop over `CELESTIAL_BODIES_DATA` to check general structure, required keys (`name`, `mass`, `radius`, `gravitational_parameter_mu`), their types, and non-negative values for all entries.
    *   **Inputs**: Iterates directly through `CELESTIAL_BODIES_DATA`.
    *   **Outputs**: Assertions on the types and values of data within `CELESTIAL_BODIES_DATA`.

### Dependencies:

*   **`pytest`**: Testing framework.
*   **`math`**: (Imported but not directly used in the provided test functions).
*   **`unittest.mock.patch`, `unittest.mock.MagicMock`**: For mocking dependencies in tests.
*   **`celestial_data` (local module)**: Imports `GRAVITATIONAL_CONSTANT`, `SPEED_OF_LIGHT`, `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA`.
*   **`constants` (local module)**: Imports `G_GRAVITATIONAL`, `C_LIGHT_MPS` for comparison against re-exported values.

---


## `tests/test_constants.py`

This file contains unit tests for physical constants defined in a `constants.py` module. It verifies the types and values of these constants and ensures that a deprecated alias for a constant has been removed.

### Key Components

*   `test_gravitational_constant_value_and_type()`
    *   **Inputs**: None (implicitly accesses `G_GRAVITATIONAL` from `constants`).
    *   **Outputs/Side Effects**: Asserts that `G_GRAVITATIONAL` is a float and its value matches `6.67430e-11` within a specified relative tolerance.
*   `test_speed_of_light_value_and_type()`
    *   **Inputs**: None (implicitly accesses `C_LIGHT_MPS` from `constants`).
    *   **Outputs/Side Effects**: Asserts that `C_LIGHT_MPS` is a float and its value matches `299_792_458.0` within a specified relative tolerance.
*   `test_no_deprecated_gravitational_constant_alias()`
    *   **Inputs**: None (implicitly attempts to access a removed attribute `GRAVITATIONAL_CONSTANT` from `constants`).
    *   **Outputs/Side Effects**: Asserts that attempting to access `GRAVITATIONAL_CONSTANT` from the `constants` module raises an `AttributeError`, confirming its removal. Includes module reloading logic using `sys`.

### Dependencies

*   `pytest`
*   `constants` (specifically `G_GRAVITATIONAL`, `C_LIGHT_MPS`)
*   `sys` (used for module manipulation in `test_no_deprecated_gravitational_constant_alias`)

---


## `tests/test_new_orbital_mechanics.py`

This file contains a comprehensive suite of unit tests for orbital mechanics calculations, specifically `calculate_orbital_velocity`, `calculate_escape_velocity`, and `calculate_orbital_period`. It uses `pytest` for testing and `unittest.mock` for patching dependencies, ensuring the functions handle valid inputs, invalid types, and various error conditions correctly.

### Key Components:

*   **`mock_get_celestial_body_data` function**:
    *   **Inputs**: `body_name` (string).
    *   **Outputs**: Returns celestial data (dictionary) for the given body from `CELESTIAL_BODIES_DATA` or `None` if not found.
*   **`TestOrbitalVelocity` class**:
    *   Tests the `calculate_orbital_velocity` function.
    *   **Inputs**: `body_name`, `distance`, `central_body_name`, `expected_velocity_m_s`, `tolerance` for valid cases; various invalid types or values for error cases.
    *   **Outputs**: Asserts the calculated velocity matches the expected value within a tolerance for valid inputs, or asserts `TypeError` / `ValueError` with specific messages for invalid inputs/data.
*   **`TestEscapeVelocity` class**:
    *   Tests the `calculate_escape_velocity` function.
    *   **Inputs**: `body_name`, `distance`, `expected_velocity_m_s`, `tolerance` for valid cases; various invalid types or values for error cases.
    *   **Outputs**: Asserts the calculated velocity matches the expected value within a tolerance for valid inputs, or asserts `TypeError` / `ValueError` with specific messages for invalid inputs/data.
*   **`TestOrbitalPeriod` class**:
    *   Tests the `calculate_orbital_period` function.
    *   **Inputs**: `body_name`, `central_body_name`, `expected_period_s`, `tolerance` for valid cases; various invalid types or values for error cases.
    *   **Outputs**: Asserts the calculated period matches the expected value within a tolerance for valid inputs, or asserts `TypeError` / `ValueError` with specific messages for invalid inputs/data.

### Dependencies:

*   `pytest`: Framework for writing tests.
*   `math`: For mathematical operations like `sqrt` and `isclose`.
*   `unittest.mock`: For patching `get_celestial_body_data` and modifying dictionaries during tests.
*   `typing`: For type hints (`Optional`, `Dict`, `Any`).
*   `src.astrophysics.orbital_calculations`: Imports `calculate_orbital_velocity`, `calculate_escape_velocity`, `calculate_orbital_period` (the functions under test).
*   `src.celestial_data.CELESTIAL_BODIES_DATA`: Provides real-world celestial body data used for test setup and mocking.

---


## `tests/test_orbital_calculations.py`

```markdown
## Analysis of `tests/test_orbital_calculations.py`

### 1. Purpose
This file serves as a comprehensive Pytest test suite for the `orbital_calculations` module, verifying its functions related to celestial mechanics calculations. It includes a robust mock implementation of `orbital_calculations` to ensure tests can run even if the actual module is not present, simulating expected behavior and error handling.

### 2. Key Components

*   **`MockOrbitalCalculations` class**:
    *   **Purpose**: A mock class that replicates the interface and basic functionality of the `orbital_calculations` module. It contains simplified implementations for testing scenarios, including input validation and basic return values.
    *   **`solve_keplers_equation(mean_anomaly: float, eccentricity: float, tolerance: float = 1e-9, max_iterations: int = 100) -> float`**:
        *   **Inputs**: Mean anomaly, eccentricity, an optional tolerance for convergence, and maximum iterations.
        *   **Outputs**: The eccentric anomaly as a float. Raises `TypeError` for non-numeric inputs or `ValueError` for out-of-range eccentricity `[0, 1)`.
    *   **`calculate_instantaneous_position_magnitude(body_name: str, time_since_epoch: float, reference_body_name: str = 'Sun') -> float | None`**:
        *   **Inputs**: Name of the celestial body, time elapsed since epoch, and an optional reference body name.
        *   **Outputs**: The scalar distance magnitude as a float, or `None` if the body is unknown or calculation fails. Raises `TypeError` for invalid input types.
    *   **`calculate_distance_between_bodies(body1_name: str, body2_name: str, time_since_epoch: float) -> float | None`**:
        *   **Inputs**: Names of two celestial bodies, and time since epoch.
        *   **Outputs**: The distance between the bodies as a float, or `None` if the pair is unknown. Returns `0.0` if `body1_name` and `body2_name` are the same. Raises `TypeError` for invalid input types.
    *   **`calculate_hohmann_delta_v(source_body_name: str, target_body_name: str) -> float | None`**:
        *   **Inputs**: Names of the source and target celestial bodies for a Hohmann transfer.
        *   **Outputs**: The total delta-v required as a float, or `None` if bodies are unknown, data is missing/invalid, or the transfer is not applicable. Returns `0.0` if source and target are the same. Raises `TypeError` for invalid input types.

*   **`TestOrbitalCalculations` class**:
    *   **Purpose**: Contains multiple Pytest methods to thoroughly test the `orbital_calculations` module's functions for accuracy, edge cases, and error handling.
    *   **Test Methods (e.g., `test_solve_keplers_equation_accuracy`, `test_calculate_instantaneous_position_magnitude_invalid_inputs`, `test_calculate_hohmann_delta_v_non_existent_body`)**:
        *   **Inputs**: Varied inputs, often parametrized with `@pytest.mark.parametrize`, covering valid values, known-accurate results, invalid types, and non-existent entities.
        *   **Outputs/Side Effects**: Assertions using `pytest.approx` or `math.isclose` for numerical accuracy, `pytest.raises` for expected error types and messages, and checks for `None` returns in error/unknown scenarios.

### 3. Dependencies
*   `pytest`: For test discovery, execution, and parametrization.
*   `math`: For mathematical operations (e.g., `sin`, `cos`, `fabs`, `isclose`).
*   `unittest.mock.patch`, `unittest.mock.MagicMock`: For advanced mocking capabilities, though `MockOrbitalCalculations` is a custom mock.
*   `src.astrophysics.orbital_calculations`: The actual module being tested (attempted import, falls back to mock if not found).
*   `celestial_data`: Used to import `get_celestial_body_data` and `GRAVITATIONAL_CONSTANT` for test data and potential comparisons.
*   `constants`: Used to import `G_GRAVITATIONAL` (for potential comparisons).
```

---
