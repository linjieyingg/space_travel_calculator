# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 22

**Last Updated:** 2025-11-18 22:34:57

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

This module `celestial_data.py` acts as a central repository for astrophysical data on solar system bodies within the `space_travel_calculator` application. It stores detailed parameters for celestial bodies and provides functions to retrieve this data and list potential travel destinations.

### Key Components:

*   **`GRAVITATIONAL_CONSTANT` and `SPEED_OF_LIGHT`**:
    *   **Description**: Universal physical constants re-exported for convenience and consistency.
    *   **Inputs**: None (directly imported from `constants`).
    *   **Outputs**: Constant values.
*   **`CELESTIAL_BODIES_DATA`**:
    *   **Description**: A dictionary containing detailed astrophysical parameters (mass, radius, gravitational parameter, semi-major axis from Sun, average distance from Earth for Moon) for various celestial bodies in the solar system.
    *   **Inputs**: None (static data definition).
    *   **Outputs**: Structured data for celestial bodies.
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Description**: Retrieves the astrophysical data for a specified celestial body.
    *   **Inputs**: `body_name` (string, case-insensitive name of the celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Description**: Generates a sorted list of potential solar system destinations from Earth, including their names and calculated distances.
    *   **Inputs**: None (uses the internal `CELESTIAL_BODIES_DATA`).
    *   **Outputs**: A list of dictionaries, each with a 'name' and 'distance' (from Earth) in meters, sorted by distance. Returns `None` if Earth's data is unavailable.

### Dependencies:

*   **`math`**: Used for `fabs()` in distance calculations.
*   **`constants`**: Provides `G_GRAVITATIONAL` and `C_LIGHT_MPS` universal physical constants.

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
This file, `fuel_optimizer.py`, calculates the optimal fuel mass required for a spacecraft's trajectory by integrating mission parameters with trajectory planning and propulsion system models. It uses the Tsiolkovsky rocket equation principles, applying required delta-V from a trajectory planner to a propulsion system's specific impulse.

### Key Components:

*   **`optimize_fuel_for_trajectory` function:**
    *   **Inputs:** `start_body` (str), `end_body` (str), `trajectory_type` (str, currently only 'Hohmann' supported), `spacecraft_dry_mass` (float), `engine_specific_impulse` (float), and `**trajectory_args` (additional arguments for the trajectory planner).
    *   **Outputs:** A `float` representing the calculated optimal fuel mass in kilograms.
    *   **Process:** Instantiates `TrajectoryPlanner`, calls `plan_hohmann_trajectory` to obtain the total delta-V, then uses the `calculate_fuel_mass_from_delta_v` function to compute the fuel mass, performing extensive input validation and error handling throughout.

### Dependencies:

*   **`math`**: Standard Python math module (imported but not explicitly used in the provided code snippet).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`) to determine fuel mass based on delta-V and engine efficiency.
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class, which is used to plan trajectories and provide the required delta-V.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
## Analysis of `main.py`

### Purpose
This file implements a space travel calculator that determines the time, fuel requirements, and cost for a user to reach a chosen celestial destination. It accounts for relativistic effects, orbital mechanics (specifically Hohmann transfers), and logs the travel details.

### Key Components

*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**
    *   **Inputs**: `years_traveler_frame` (float), `average_speed_ms` (float)
    *   **Outputs**: `float` (travel time in Earth's reference frame), potentially `float('inf')` or traveler's time on error/invalid speed.
    *   **Side Effects**: Prints warnings for invalid speeds or calculation errors.
*   **`calc_age(years_travel_time, starting_age)`**
    *   **Inputs**: `years_travel_time` (float), `starting_age` (int)
    *   **Outputs**: `float` (user's age upon arrival).
    *   **Side Effects**: Raises `ValueError` for invalid inputs.
*   **`calc_arrival(departure_date, years_earth_frame)`**
    *   **Inputs**: `departure_date` (datetime), `years_earth_frame` (float)
    *   **Outputs**: `datetime.datetime` (estimated arrival date) or `None` on failure.
    *   **Side Effects**: Prints warnings or errors for calculation issues.
*   **`convert_date(date_str)`**
    *   **Inputs**: `date_str` (string in 'YYYY-MM-DD' format)
    *   **Outputs**: `datetime.datetime` object.
*   **`main()`**
    *   **Inputs**: User input via `input()` prompts.
    *   **Outputs**: Prints a detailed travel summary to the console.
    *   **Side Effects**: Orchestrates the entire application flow:
        *   Collects user inputs (departure/arrival bodies, spacecraft mass, engine specific impulse, departure date, age, fuel price).
        *   Utilizes `TrajectoryPlanner` for Hohmann transfer planning.
        *   Uses `fuel_optimizer` and `fuel_calc` to determine fuel mass and cost.
        *   Calculates relativistic travel time and arrival age/date using internal functions.
        *   Saves travel details using `travel_logger`.
        *   Handles various errors and provides informative messages.

### Dependencies
*   **Standard Library**:
    *   `math`
    *   `datetime` (specifically `datetime`, `timedelta`)
*   **Local Modules**:
    *   `checks as c` (presumably for input validation)
    *   `celestial_data` (for retrieving celestial body information)
    *   `orbital_mechanics` (imported but `calculate_circular_orbital_velocity` is not directly used in `main`)
    *   `trajectory_planner` (specifically `TrajectoryPlanner` class)
    *   `propulsion_system` (imported but not directly used in `main`)
    *   `fuel_calc` (for fuel cost calculation)
    *   `travel_logger` (for saving travel details)
    *   `constants` (specifically `C_LIGHT_MPS`)
    *   `fuel_optimizer` (for optimizing fuel mass)
```

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_fuel_optimizer.py`

This file contains a comprehensive suite of pytest unit tests for the `optimize_fuel_for_trajectory` function within the `fuel_optimizer` module. It aims to verify the function's correct behavior across various scenarios, including successful execution, invalid inputs, error handling from internal dependencies, and unexpected return values from those dependencies.

### Key Components:

*   **`mock_dependencies_for_fuel_optimizer` (pytest fixture)**:
    *   **Inputs**: None (internally patches `fuel_optimizer.TrajectoryPlanner` and `fuel_optimizer.calculate_fuel_mass_from_delta_v`).
    *   **Outputs/Side Effects**: Yields a dictionary of configured mock objects, simulating a successful Hohmann trajectory plan with a fixed total delta-v and a fixed fuel mass calculation. This isolates the `optimize_fuel_for_trajectory` function for testing.
*   **`test_optimize_fuel_for_trajectory_success`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Asserts that `optimize_fuel_for_trajectory` returns the expected fuel mass and that the mocked external calls were made correctly.
*   **`test_optimize_fuel_for_trajectory_unsupported_trajectory_type`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Verifies that a `ValueError` is raised for unsupported trajectory types and that no dependencies are called.
*   **`test_optimize_fuel_for_trajectory_invalid_inputs` (parameterized)**:
    *   **Inputs**: `dry_mass`, `specific_impulse`, `expected_error` (via `pytest.mark.parametrize`).
    *   **Outputs/Side Effects**: Checks that `ValueError` is raised for invalid (non-positive or non-numeric) `spacecraft_dry_mass` or `engine_specific_impulse`.
*   **`test_optimize_fuel_for_trajectory_planner_returns_unsuccessful`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Tests error propagation when the mocked `TrajectoryPlanner` indicates an unsuccessful plan, expecting a `ValueError`.
*   **`test_optimize_fuel_for_trajectory_planner_returns_invalid_delta_v`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Asserts a `ValueError` is raised if the mocked planner returns a negative delta-v.
*   **`test_optimize_fuel_for_trajectory_propulsion_system_raises_error`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Verifies that `ValueError` from the mocked fuel mass calculation function is caught and re-raised appropriately.
*   **`test_optimize_fuel_for_trajectory_propulsion_returns_negative_fuel`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Confirms a `ValueError` is raised if the mocked fuel mass calculation returns a negative value.
*   **`test_optimize_fuel_for_trajectory_planner_raises_runtime_error`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Tests error handling when the mocked `TrajectoryPlanner` raises an unexpected `RuntimeError`.
*   **`test_optimize_fuel_for_trajectory_planner_raises_type_error_with_kwargs`**:
    *   **Inputs**: The `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs/Side Effects**: Simulates a `TypeError` from the planner due to unexpected arguments and expects a `ValueError` indicating a method signature mismatch.

### Dependencies:

*   `pytest`: The testing framework.
*   `unittest.mock.MagicMock`, `unittest.mock.patch`: For creating and managing mock objects.
*   `fuel_optimizer`: Imports `optimize_fuel_for_trajectory` (the function under test) and `TrajectoryPlanner` (a dependency of the function under test).

---


## `tests/test_main.py`

This file is a comprehensive pytest suite designed to test the `main.py` application. It uses extensive mocking to isolate the `main.py` logic from its dependencies, ensuring that the application's workflow, calculations, user interactions, and error handling are robust.

### Key Components:

*   **`mock_dependencies` (Pytest fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Patches numerous external modules (`celestial_data`, `trajectory_planner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `c` for checks) and built-in functions (`input`, `print`) that `main.py` relies on. It pre-configures these mocks with specific return values or side effects (e.g., pre-defined celestial data, successful trajectory results, fuel costs) to simulate typical execution and specific error conditions. It yields a dictionary of these mock objects for use in test functions.

*   **`test_main_function_integrates_all_components_correctly` (Test Function)**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Simulates a full successful user interaction with `main.main()` by providing mock inputs. It asserts that all relevant mocked functions (data retrieval, planning, optimization, calculation, logging) are called exactly once and with the correct parameters, verifying the integration flow. It also checks `print` outputs for correct summary information, fuel costs, relativistic time dilation, arrival date, and age upon arrival.

*   **Error Handling Tests (e.g., `test_main_function_trajectory_planner_fails`, `test_main_function_fuel_optimizer_raises_value_error`, `test_main_function_get_all_solar_system_destinations_fails`) (Test Functions)**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: These tests configure specific mocks to simulate various failure scenarios (e.g., trajectory planning failure, exceptions during fuel optimization, no destinations found). They then call `main.main()` and assert that appropriate error messages are printed and that subsequent processing steps are not executed.

*   **Helper Function Tests (e.g., `test_calc_time_earth_relativistic_zero_speed`, `test_calc_age_valid_inputs`, `test_calc_arrival_valid_inputs`, `test_convert_date_valid`) (Test Functions)**:
    *   **Inputs**: Direct arguments for helper functions within `main.py` (e.g., `travel_time_seconds`, `speed_mps`, `start_age_years`, `departure_date`, `years_earth_frame`, `date_str`).
    *   **Outputs/Side Effects**: Directly call and test specific utility functions within `main.py` for correctness, including edge cases (e.g., zero speed, speed of light, invalid inputs, date overflows) and expected `ValueError` exceptions or printed warnings.

*   **`test_main_function_average_speed_fallback` (Test Function)**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Tests the fallback mechanism for average speed calculation. It simulates a zero average speed from the trajectory planner and verifies that `main.main()` prints a warning and uses a default fallback speed (0.1% of C_LIGHT_MPS) for relativistic calculations and logging.

### Dependencies:

*   `pytest`: Testing framework.
*   `unittest.mock.patch`, `MagicMock`, `call`: For creating mock objects and patching dependencies.
*   `datetime`, `timedelta`: For handling date and time objects.
*   `math`: For mathematical functions used in relativistic calculations.
*   `sys`: Imported but not explicitly used in the provided test content.
*   `main`: The primary application module being tested.
*   `constants.C_LIGHT_MPS`: A constant representing the speed of light, used in relativistic calculations and assertions.

---


## `tests/test_trajectory_planner.py`

This file, `tests/test_trajectory_planner.py`, contains unit tests for the `TrajectoryPlanner` class, specifically focusing on its initialization and the `plan_hohmann_trajectory` method. It uses mocking to isolate the `TrajectoryPlanner` logic from its external data and calculation dependencies.

### Key Components:

*   **`mock_celestial_data_for_planner` (pytest fixture)**:
    *   **Inputs**: None directly, but configures a mock for `celestial_data.get_celestial_body_data` that takes a celestial body `name`.
    *   **Outputs/Side effects**: Returns a dictionary containing predefined mock data for 'Sun', 'Earth', 'Mars', and 'Jupiter', or `None` if the body is not in the mock list. This mock is yielded for use in tests.
*   **`mock_orbital_mechanics` (pytest fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side effects**: Mocks `orbital_mechanics.calculate_hohmann_transfer_delta_v` to return a fixed `(1000.0, 2000.0, 3000.0)` tuple and `orbital_mechanics.calculate_hohmann_transfer_time_of_flight` to return `100 * 24 * 3600` seconds (100 days). The mock objects are yielded.
*   **Tests for `TrajectoryPlanner.__init__`**:
    *   **Inputs**: Primarily uses the `mock_celestial_data_for_planner` fixture.
    *   **Outputs/Side effects**: Contains multiple test functions to ensure `TrajectoryPlanner` initializes correctly when Sun data is valid, and raises appropriate `ValueError` or `AttributeError` exceptions when Sun data is missing, incomplete, or invalid (`gravitational_parameter_mu` field).
*   **Tests for `TrajectoryPlanner.plan_hohmann_trajectory`**:
    *   **Inputs**: Uses both `mock_celestial_data_for_planner` and `mock_orbital_mechanics` fixtures, and provides various string inputs for departure and arrival bodies.
    *   **Outputs/Side effects**: Contains numerous test functions to verify:
        *   Successful Hohmann transfer calculation between valid bodies (e.g., Earth to Mars), checking the correctness of returned `delta_v`, `travel_time_days`, and formatted `travel_time_h_m_s`.
        *   Robust input validation for empty, whitespace-only, or non-string body names.
        *   Handling of identical departure and arrival bodies.
        *   Error handling for non-existent departure/arrival bodies or missing/invalid `semi_major_axis_from_sun` data.
        *   Graceful error reporting when underlying `orbital_mechanics` functions raise expected (`ValueError`) or unexpected exceptions.
        *   Accurate formatting of travel time, including fractional days.

### Dependencies:

*   `pytest`: Testing framework for test execution, fixtures, and assertions (`pytest.approx`, `pytest.raises`).
*   `unittest.mock.patch`, `unittest.mock.MagicMock`: For creating mock objects and patching dependencies.
*   `datetime.timedelta`: Imported, likely used by the `TrajectoryPlanner` class for time calculations and formatting.
*   `math`: Imported, likely used by the `TrajectoryPlanner` or its dependencies for mathematical operations.
*   `trajectory_planner`: The main module containing the class under test.
*   `celestial_data`: A module containing functions (e.g., `get_celestial_body_data`) that `TrajectoryPlanner` depends on, which are mocked in these tests.
*   `orbital_mechanics`: A module containing functions (e.g., `calculate_hohmann_transfer_delta_v`, `calculate_hohmann_transfer_time_of_flight`) that `TrajectoryPlanner` depends on, which are mocked in these tests.
*   `constants`: Imported, likely a dependency for `TrajectoryPlanner` or its related modules, but not directly mocked or asserted in this test file.

---


## `trajectory_planner.py`

```markdown
This file defines a `TrajectoryPlanner` class that serves as a high-level interface for planning interplanetary trajectories, specifically focusing on Hohmann transfers between celestial bodies orbiting the Sun. It orchestrates calls to underlying orbital mechanics functions and celestial data to calculate optimal paths.

### Key Components:

*   **Class: `TrajectoryPlanner`**
    *   **`__init__(self)`**
        *   **Inputs**: None directly; internally retrieves 'Sun' data from `celestial_data`.
        *   **Outputs/Side Effects**: Initializes `self.mu_sun` (Sun's gravitational parameter). Raises `ValueError` or `AttributeError` if Sun data is not found or invalid.
    *   **`plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str) -> dict`**
        *   **Inputs**: `departure_body_name` (str), `arrival_body_name` (str) - names of celestial bodies.
        *   **Outputs**: A dictionary containing trajectory details such as `total_delta_v_mps`, `travel_time_days`, `travel_time_h_m_s`, and a `success` status with optional `error` message. Returns an error dictionary if inputs are invalid or data is missing/incorrect.
*   **Main Execution Block (`if __name__ == '__main__':`)**
    *   **Inputs**: Hardcoded example calls to `plan_hohmann_trajectory` with various valid and invalid body names.
    *   **Outputs/Side Effects**: Prints the results of the planned trajectories (or error messages) to the console for demonstration and testing purposes.

### Dependencies:

*   `math`
*   `datetime.timedelta`
*   `orbital_mechanics` (custom module for core orbital calculations)
*   `celestial_data` (custom module for retrieving celestial body properties)
*   `constants.G_GRAVITATIONAL` (imported, but not directly used within the `TrajectoryPlanner` class in this file, likely used by `orbital_mechanics`)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
