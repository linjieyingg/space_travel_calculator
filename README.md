# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 18

**Last Updated:** 2025-11-18 21:44:47

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

```markdown
## celestial_data.py Summary

This module serves as the central data repository for astrophysical data within the `space_travel_calculator` application, providing detailed parameters for solar system bodies and functions to retrieve this information and list potential travel destinations. It also re-exports universal physical constants for consistency.

### Key Components:

*   **`GRAVITATIONAL_CONSTANT`**: Global constant (float) re-exported from `constants`.
*   **`SPEED_OF_LIGHT`**: Global constant (float) re-exported from `constants`.
*   **`CELESTIAL_BODIES_DATA`**: A dictionary storing astrophysical data (mass, radius, gravitational parameter, average orbital radius) for various celestial bodies in the solar system.
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Inputs**: `body_name` (string, case-insensitive name of a celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Inputs**: None.
    *   **Outputs**: A list of dictionaries, each with a celestial body's `name` (string) and its calculated average `distance` (float) from Earth in meters, sorted by distance. Returns `None` if Earth's data is missing.

### Dependencies:

*   `math`: Used for `math.fabs()` in distance calculations.
*   `constants`: Imports `G_GRAVITATIONAL` and `C_LIGHT_MPS` for re-export.
```

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

### fuel_optimizer.py

1.  **Purpose**
    This file calculates the optimal fuel mass required for a planned space trajectory by integrating delta-V requirements from a trajectory planner with propulsion system physics. It acts as an orchestrator between orbital mechanics and rocket equation calculations.

2.  **Key Components**
    *   `calculate_fuel_mass_from_delta_v` (Mock/Imported from `propulsion_system.py`)
        *   **Inputs**: `delta_v` (float), `spacecraft_dry_mass` (float), `specific_impulse` (float)
        *   **Output**: Calculated fuel mass in kilograms (float).
    *   `calculate_delta_v` (Mock/Imported from `trajectory_planner.py`)
        *   **Inputs**: `start_body` (str), `end_body` (str), `trajectory_type` (str), and optional `**kwargs` for trajectory specifics.
        *   **Output**: Required change in velocity (delta-V) in meters per second (float).
    *   `optimize_fuel_for_trajectory` (Main function)
        *   **Inputs**: `start_body` (str), `end_body` (str), `trajectory_type` (str), `spacecraft_dry_mass` (float), `engine_specific_impulse` (float), and optional `**trajectory_args`.
        *   **Output**: The calculated optimal fuel mass in kilograms (float).
        *   **Side Effects**: Raises `ValueError` for invalid inputs or invalid results from dependency functions, and `RuntimeError` for unexpected errors during the optimization process.

3.  **Dependencies**
    *   `math` (Python standard library)
    *   `sys` (Python standard library)
    *   `os` (Python standard library - imported but not explicitly used in the provided code)
    *   `propulsion_system` (Custom module, expected to contain `calculate_fuel_mass_from_delta_v`)
    *   `trajectory_planner` (Custom module, expected to contain `calculate_delta_v`)

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
### Purpose
This file implements a space travel calculator that determines the time, fuel, and cost required for a user to travel between chosen celestial bodies, incorporating relativistic effects and orbital mechanics.

### Key Components
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: Travel time in the traveler's frame (years), average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years).
*   **`calc_age(years, age)`**:
    *   **Inputs**: Travel time (years), user's starting age (int).
    *   **Outputs**: User's age upon arrival (int).
*   **`calc_arrival(date, years_earth_frame)`**:
    *   **Inputs**: Departure date (`datetime`), travel time in Earth's frame (years).
    *   **Outputs**: Estimated arrival date (`datetime`) or `None` if calculation fails.
*   **`convert_date(date_str)`**:
    *   **Inputs**: Date string in 'YYYY-MM-DD' format.
    *   **Outputs**: `datetime` object.
*   **`main()` function**:
    *   **Inputs**: Interactive user inputs for source/destination planets, spacecraft dry mass, engine specific impulse, departure date, and user age.
    *   **Outputs/Side Effects**:
        *   Orchestrates the entire calculation process: gathers user input, calls external modules for trajectory planning, fuel calculation, and logging.
        *   Prints a detailed travel summary including required Delta-V, fuel mass, cost, travel times (traveler's and Earth's frames), user's age upon arrival, and estimated arrival date to the console.
        *   Logs travel details using the `travel_logger` module.

### Dependencies
*   `datetime` (standard library)
*   `math` (standard library)
*   `checks` (local module aliased as `c`)
*   `celestial_data` (local module)
*   `orbital_mechanics` (local module)
*   `trajectory_planner` (local module)
*   `propulsion_system` (local module)
*   `fuel_calc` (local module)
*   `travel_logger` (local module)
*   `constants` (local module)
```

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `trajectory_planner.py`

```markdown
## File Analysis: `trajectory_planner.py`

### Purpose
This file defines the `TrajectoryPlanner` class, which serves as a high-level interface for planning interplanetary trajectories. It orchestrates calls to underlying orbital mechanics functions to calculate optimal paths, specifically focusing on Hohmann transfers for minimum energy.

### Key Components
*   **Class: `TrajectoryPlanner`**
    *   **`__init__(self)`**
        *   **Inputs:** None (initializes `self` object).
        *   **Outputs/Side Effects:** Fetches the Sun's gravitational parameter (`mu_sun`) from the `celestial_data` module and stores it. Raises `ValueError` or `AttributeError` if Sun data is missing or incomplete.
    *   **`plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str) -> dict`**
        *   **Inputs:** `departure_body_name` (string) and `arrival_body_name` (string) representing celestial bodies.
        *   **Outputs:** A dictionary containing detailed trajectory information, including departure/arrival bodies, transfer type ("Hohmann Transfer"), total delta-v in m/s, total travel time in days and a formatted string, a success flag, and an error message if applicable.
        *   **Side Effects:** Retrieves orbital data from `celestial_data`, calls `orbital_mechanics` functions to calculate delta-v and time of flight, and formats the results. Includes extensive input validation.
*   **Main Execution Block (`if __name__ == '__main__':`)**
    *   **Inputs:** Hardcoded string names for celestial bodies (e.g., "Earth", "Mars", "Jupiter", "Pluto").
    *   **Outputs/Side Effects:** Demonstrates the `TrajectoryPlanner`'s functionality by planning example trajectories and printing the results or any encountered errors to the console.

### Dependencies
*   `math`
*   `datetime.timedelta`
*   `orbital_mechanics` (local module)
*   `celestial_data` (local module)
*   `constants.G_GRAVITATIONAL` (imported from `constants`, though `mu_sun` is sourced from `celestial_data` directly in this file's implementation).
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
