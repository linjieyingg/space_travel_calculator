# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 21

**Last Updated:** 2025-11-18 22:24:58

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

This module `celestial_data.py` acts as a central repository for astrophysical data on solar system bodies within the `space_travel_calculator` application. It stores detailed parameters for celestial bodies and provides functions to retrieve this data and list potential travel destinations.

### Key Components:

*   **`GRAVITATIONAL_CONSTANT` and `SPEED_OF_LIGHT`**:
    *   **Description**: Universal physical constants re-exported for convenience and consistency.
    *   **Inputs**: None (directly imported from `constants`).
    *   **Outputs**: Constant values.
*   **`CELESTIAL_BODIES_DATA`**:
    *   **Description**: A dictionary containing detailed astrophysical parameters (mass, radius, gravitational parameter, semi-major axis from Sun, average distance from Earth for Moon) for various celestial bodies in the solar system.
    *   **Inputs**: None (static data definition).
    *   **Outputs**: Structured data for celestial bodies.
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Description**: Retrieves the astrophysical data for a specified celestial body.
    *   **Inputs**: `body_name` (string, case-insensitive name of the celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Description**: Generates a sorted list of potential solar system destinations from Earth, including their names and calculated distances.
    *   **Inputs**: None (uses the internal `CELESTIAL_BODIES_DATA`).
    *   **Outputs**: A list of dictionaries, each with a 'name' and 'distance' (from Earth) in meters, sorted by distance. Returns `None` if Earth's data is unavailable.

### Dependencies:

*   **`math`**: Used for `fabs()` in distance calculations.
*   **`constants`**: Provides `G_GRAVITATIONAL` and `C_LIGHT_MPS` universal physical constants.

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## Analysis of fuel_optimizer.py

### Purpose
This file orchestrates the calculation of optimal fuel mass for space trajectories. It integrates trajectory planning (to determine required delta-V) with propulsion system models (to calculate fuel based on delta-V and engine efficiency).

### Key Components

*   **`calculate_fuel_mass_from_delta_v` (Function)**
    *   **Description:** (Mock implementation) Calculates the fuel mass required based on the Tsiolkovsky rocket equation. In a production environment, this function would be imported from `propulsion_system.py`.
    *   **Inputs:** `delta_v` (float), `spacecraft_dry_mass` (float), `specific_impulse` (float).
    *   **Outputs:** Required `fuel_mass` (float) in kilograms.

*   **`TrajectoryPlanner` (Class, Imported)**
    *   **Description:** An external class (imported from `trajectory_planner.py`) responsible for planning space trajectories and determining the total delta-V required.
    *   **Inputs:** Its `plan_hohmann_trajectory` method takes `departure_body_name`, `arrival_body_name`, and additional `**trajectory_args`.
    *   **Outputs:** A dictionary containing trajectory details, including `total_delta_v` (float).

*   **`optimize_fuel_for_trajectory` (Function)**
    *   **Description:** The main function that drives the fuel optimization process. It instantiates `TrajectoryPlanner`, calls its `plan_hohmann_trajectory` method, and then uses the resulting delta-V with the fuel calculation function to determine the total fuel mass.
    *   **Inputs:** `start_body` (str), `end_body` (str), `trajectory_type` (str - currently only 'Hohmann' is supported), `spacecraft_dry_mass` (float), `engine_specific_impulse` (float), and `**trajectory_args` (keyword arguments passed to the trajectory planner).
    *   **Outputs:** The `fuel_mass` (float) in kilograms required for the planned trajectory.

### Dependencies
*   **`math`**: Standard library, used for `math.exp` in the mock `calculate_fuel_mass_from_delta_v`.
*   **`sys`**: Standard library, used for printing warnings to `sys.stderr`.
*   **`os`**: Standard library, imported but not used in the provided code snippet.
*   **`propulsion_system`**: External module, expected to provide `calculate_required_fuel_mass`. A mock implementation is provided if it's not found, allowing for development/testing.
*   **`trajectory_planner`**: External module, expected to provide the `TrajectoryPlanner` class. This is a critical dependency, and an `ImportError` is raised if it cannot be found.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
This file, `main.py`, is the core executable for a space travel calculator. It takes user inputs for a space journey, calculates various parameters like travel time (accounting for relativistic effects), fuel requirements, costs, and arrival dates, and then presents a comprehensive summary.

### Key Components:

*   **`main()` function**:
    *   **Inputs**: Gathers interactive user inputs such as departure/arrival bodies, spacecraft dry mass, engine specific impulse, departure date, user's current age, and fuel price per unit.
    *   **Outputs/Side Effects**: Orchestrates all calculations, prints a detailed travel summary to the console, and logs travel details via `travel_logger`.
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: Travel time in the traveler's frame (years) and average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years), applying relativistic time dilation. Handles edge cases for speed.
*   **`calc_age(years_travel_time, starting_age)`**:
    *   **Inputs**: Total travel time (years) and user's starting age (int).
    *   **Outputs**: User's calculated age upon arrival (float).
*   **`calc_arrival(departure_date, years_earth_frame)`**:
    *   **Inputs**: Departure date (`datetime`) and total travel years in Earth's frame (float).
    *   **Outputs**: Estimated arrival date (`datetime.datetime`) or `None` if calculation fails.
*   **`convert_date(date_str)`**:
    *   **Inputs**: Date string in 'YYYY-MM-DD' format.
    *   **Outputs**: Converted `datetime.datetime` object.
*   **Integration with External Modules**:
    *   **`TrajectoryPlanner`**: Plans the mission trajectory (e.g., Hohmann transfer) based on departure/arrival bodies, providing total Delta-V, travel time (traveler's frame), and average speed.
    *   **`fuel_optimizer`**: Calculates the optimized fuel mass required for the planned trajectory, given spacecraft mass and engine specific impulse.
    *   **`fuel_calc`**: Determines the total cost of the required fuel.
    *   **`travel_logger`**: Saves the calculated travel details for historical record.

### Dependencies:

*   **Standard Library**: `math`, `datetime`, `timedelta`
*   **Local Modules**: `checks` (aliased as `c`), `celestial_data`, `orbital_mechanics` (imported but not directly used in `main`), `trajectory_planner`, `propulsion_system` (imported but not directly used in `main`), `fuel_calc`, `travel_logger`, `constants`, `fuel_optimizer`.
```

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_main.py`

```markdown
This file contains integration and unit tests for the `main.py` module, designed to verify its core functionality and error handling. It uses `pytest` for the testing framework and `unittest.mock` for isolating `main.py` from its external dependencies.

### Key Components:

*   **`mock_dependencies` fixture**:
    *   **Inputs**: None directly, but it patches several functions and classes within the `main` module's scope (`celestial_data.get_celestial_body_data`, `celestial_data.get_all_solar_system_destinations`, `TrajectoryPlanner`, `fuel_optimizer.optimize_fuel_for_trajectory`, `fuel_calc.calculate_fuel_cost`, `travel_logger.save_travel_log`, `builtins.input`, `builtins.print`).
    *   **Outputs/Side Effects**: Returns a dictionary of configured mock objects. It sets `side_effect` for `input` to simulate user input sequence and `return_value` for other mocks to provide predictable data or simulate success/failure scenarios.
*   **`test_main_function_integrates_all_components_correctly`**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Calls `main.main()`. Asserts that all mocked dependencies were called with the correct arguments (e.g., `TrajectoryPlanner` instantiated, `fuel_optimizer` called with specific mass/impulse, `travel_logger` saved), and that the `mock_print` captured expected summary output including relativistic time calculations and arrival details.
*   **`test_main_function_trajectory_planner_fails`**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Simulates a failure in `TrajectoryPlanner`. Asserts an error message is printed and subsequent processing steps (fuel optimization, logging) are not called.
*   **`test_main_function_fuel_optimizer_raises_value_error`**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Simulates a `ValueError` from `fuel_optimizer`. Asserts an error message is printed and subsequent steps (fuel cost, logging) are not called.
*   **`test_main_function_fuel_cost_calculation_fails`**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Simulates `fuel_calc.calculate_fuel_cost` returning `None`. Asserts an error message is printed and logging is not called.
*   **`test_main_function_get_all_solar_system_destinations_fails`**:
    *   **Inputs**: `mock_dependencies` fixture.
    *   **Outputs/Side Effects**: Simulates `celestial_data.get_all_solar_system_destinations` returning an empty list. Asserts an error message is printed and no further inputs or calculations occur.
*   **Unit tests for `main`'s helper functions (e.g., `test_calc_time_earth_*`, `test_calc_age_*`, `test_calc_arrival_*`, `test_convert_date_*`)**:
    *   **Inputs**: Specific values for `traveler_years`, `average_speed_ms`, `current_age`, `departure_date`, `date_str`, covering valid, edge, and error cases.
    *   **Outputs/Side Effects**: Assertions on the return values, checking for correct calculations, expected behavior with edge cases (like speed of light or zero speed), and proper error/warning handling (e.g., `pytest.raises` for `ValueError`, `mock_print` for warnings).

### Dependencies:

*   `pytest`: The testing framework.
*   `math`: For mathematical functions like `sqrt`.
*   `datetime`, `timedelta` (from `datetime`): For date and time manipulation.
*   `patch`, `MagicMock`, `call` (from `unittest.mock`): For creating and managing mock objects.
*   `main`: The module under test.
*   `constants`: Provides shared constant values, like `C_LIGHT_MPS`.
*   `celestial_data`: Imported, primarily for mocking purposes within the `main` module's context.
```

---


## `tests/test_trajectory_planner.py`

This file, `tests/test_trajectory_planner.py`, contains unit tests for the `TrajectoryPlanner` class, specifically focusing on its initialization and the `plan_hohmann_trajectory` method. It uses mocking to isolate the `TrajectoryPlanner` logic from its external data and calculation dependencies.

### Key Components:

*   **`mock_celestial_data_for_planner` (pytest fixture)**:
    *   **Inputs**: None directly, but configures a mock for `celestial_data.get_celestial_body_data` that takes a celestial body `name`.
    *   **Outputs/Side effects**: Returns a dictionary containing predefined mock data for 'Sun', 'Earth', 'Mars', and 'Jupiter', or `None` if the body is not in the mock list. This mock is yielded for use in tests.
*   **`mock_orbital_mechanics` (pytest fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side effects**: Mocks `orbital_mechanics.calculate_hohmann_transfer_delta_v` to return a fixed `(1000.0, 2000.0, 3000.0)` tuple and `orbital_mechanics.calculate_hohmann_transfer_time_of_flight` to return `100 * 24 * 3600` seconds (100 days). The mock objects are yielded.
*   **Tests for `TrajectoryPlanner.__init__`**:
    *   **Inputs**: Primarily uses the `mock_celestial_data_for_planner` fixture.
    *   **Outputs/Side effects**: Contains multiple test functions to ensure `TrajectoryPlanner` initializes correctly when Sun data is valid, and raises appropriate `ValueError` or `AttributeError` exceptions when Sun data is missing, incomplete, or invalid (`gravitational_parameter_mu` field).
*   **Tests for `TrajectoryPlanner.plan_hohmann_trajectory`**:
    *   **Inputs**: Uses both `mock_celestial_data_for_planner` and `mock_orbital_mechanics` fixtures, and provides various string inputs for departure and arrival bodies.
    *   **Outputs/Side effects**: Contains numerous test functions to verify:
        *   Successful Hohmann transfer calculation between valid bodies (e.g., Earth to Mars), checking the correctness of returned `delta_v`, `travel_time_days`, and formatted `travel_time_h_m_s`.
        *   Robust input validation for empty, whitespace-only, or non-string body names.
        *   Handling of identical departure and arrival bodies.
        *   Error handling for non-existent departure/arrival bodies or missing/invalid `semi_major_axis_from_sun` data.
        *   Graceful error reporting when underlying `orbital_mechanics` functions raise expected (`ValueError`) or unexpected exceptions.
        *   Accurate formatting of travel time, including fractional days.

### Dependencies:

*   `pytest`: Testing framework for test execution, fixtures, and assertions (`pytest.approx`, `pytest.raises`).
*   `unittest.mock.patch`, `unittest.mock.MagicMock`: For creating mock objects and patching dependencies.
*   `datetime.timedelta`: Imported, likely used by the `TrajectoryPlanner` class for time calculations and formatting.
*   `math`: Imported, likely used by the `TrajectoryPlanner` or its dependencies for mathematical operations.
*   `trajectory_planner`: The main module containing the class under test.
*   `celestial_data`: A module containing functions (e.g., `get_celestial_body_data`) that `TrajectoryPlanner` depends on, which are mocked in these tests.
*   `orbital_mechanics`: A module containing functions (e.g., `calculate_hohmann_transfer_delta_v`, `calculate_hohmann_transfer_time_of_flight`) that `TrajectoryPlanner` depends on, which are mocked in these tests.
*   `constants`: Imported, likely a dependency for `TrajectoryPlanner` or its related modules, but not directly mocked or asserted in this test file.

---


## `trajectory_planner.py`

```markdown
This file defines a `TrajectoryPlanner` class that serves as a high-level interface for planning interplanetary trajectories, specifically focusing on Hohmann transfers between celestial bodies orbiting the Sun. It orchestrates calls to underlying orbital mechanics functions and celestial data to calculate optimal paths.

### Key Components:

*   **Class: `TrajectoryPlanner`**
    *   **`__init__(self)`**
        *   **Inputs**: None directly; internally retrieves 'Sun' data from `celestial_data`.
        *   **Outputs/Side Effects**: Initializes `self.mu_sun` (Sun's gravitational parameter). Raises `ValueError` or `AttributeError` if Sun data is not found or invalid.
    *   **`plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str) -> dict`**
        *   **Inputs**: `departure_body_name` (str), `arrival_body_name` (str) - names of celestial bodies.
        *   **Outputs**: A dictionary containing trajectory details such as `total_delta_v_mps`, `travel_time_days`, `travel_time_h_m_s`, and a `success` status with optional `error` message. Returns an error dictionary if inputs are invalid or data is missing/incorrect.
*   **Main Execution Block (`if __name__ == '__main__':`)**
    *   **Inputs**: Hardcoded example calls to `plan_hohmann_trajectory` with various valid and invalid body names.
    *   **Outputs/Side Effects**: Prints the results of the planned trajectories (or error messages) to the console for demonstration and testing purposes.

### Dependencies:

*   `math`
*   `datetime.timedelta`
*   `orbital_mechanics` (custom module for core orbital calculations)
*   `celestial_data` (custom module for retrieving celestial body properties)
*   `constants.G_GRAVITATIONAL` (imported, but not directly used within the `TrajectoryPlanner` class in this file, likely used by `orbital_mechanics`)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
