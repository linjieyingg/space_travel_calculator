# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 21

**Last Updated:** 2025-11-18 23:36:52

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

```markdown
## Analysis of `celestial_data.py`

### Purpose
This module serves as the definitive source for astrophysical data within the `space_travel_calculator` application, centralizing detailed parameters for solar system celestial bodies. It provides functions to retrieve this data and list potential destinations, while also re-exporting universal physical constants for consistency.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: Global constant re-exported from `constants`, representing the Gravitational Constant (m³ kg⁻¹ s⁻²).
*   **`SPEED_OF_LIGHT`**: Global constant re-exported from `constants`, representing the Speed of Light (m/s).
*   **`CELESTIAL_BODIES_DATA`**: A dictionary containing detailed astrophysical data for various celestial bodies (e.g., mass, radius, gravitational parameter, semi-major axis from Sun, orbital period).
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Inputs**: `body_name` (string, case-insensitive name of a celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Inputs**: None.
    *   **Outputs**: A list of dictionaries, each with 'name' and calculated 'distance' from Earth (in meters), sorted by distance. Returns `None` if Earth's data is missing.

### Dependencies
*   **`math`**: Used for `math.fabs()` in distance calculations.
*   **`constants`**: Imports `G_GRAVITATIONAL` (as `GRAVITATIONAL_CONSTANT`) and `C_LIGHT_MPS` (as `SPEED_OF_LIGHT`).
```

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `ephemeris.py`

This Python file, `ephemeris.py`, calculates the approximate heliocentric (Sun-centered) orbital state (distance and angular position) for celestial bodies using a simplified circular orbit model based on Kepler's laws. It provides a foundational mechanism for basic astronomical position estimations for planets.

### Key Components:

*   **`J2000_EPOCH`**: A `datetime.datetime` constant representing the J2000.0 epoch in UTC, used as a reference for time difference calculations.
*   **`_get_mu_sun()`**:
    *   **Inputs**: None.
    *   **Outputs**: Returns the Sun's gravitational parameter (mu) as a float (m^3/s^2), internally caching the result for efficiency. Raises `ValueError` if the parameter cannot be retrieved or is invalid.
*   **`get_heliocentric_state(body_name: str, date: datetime.datetime)`**:
    *   **Inputs**:
        *   `body_name` (str): The case-insensitive name of a celestial body (e.g., 'Mars').
        *   `date` (datetime.datetime): The specific date and time (timezone-aware recommended, naive dates are converted to UTC).
    *   **Outputs**: A dictionary containing:
        *   `"distance_from_sun_m"` (float): Approximate distance from the Sun in meters.
        *   `"angular_position_rad"` (float): Approximate angular position in radians (0 to 2*pi).
    *   **Side Effects**: Raises `ValueError` for invalid inputs, missing celestial data, or if the calculation is requested for the Sun or Moon (which are explicitly not supported by this simplified model).
*   **`if __name__ == '__main__':`**:
    *   **Purpose**: Contains a comprehensive self-test suite demonstrating the `get_heliocentric_state` function with valid inputs, invalid inputs, edge cases (past dates, naive datetimes), and unsupported bodies, printing results and caught errors.

### Dependencies:

*   `math`
*   `datetime`
*   `celestial_data` (specifically `get_celestial_body_data`)
*   `orbital_mechanics` (specifically `calculate_gravitational_parameter`, `calculate_elliptical_orbital_period`)

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## fuel_optimizer.py

### 1. Purpose
This file orchestrates the calculation of optimal fuel mass required for a spacecraft's trajectory. It integrates a trajectory planner to determine the necessary delta-V and then uses a propulsion system model to compute the fuel mass based on that delta-V and engine parameters.

### 2. Key Components
*   **`optimize_fuel_for_trajectory` function**:
    *   **Inputs**:
        *   `start_body` (str): Origin celestial body.
        *   `end_body` (str): Target celestial body.
        *   `trajectory_type` (str): The type of trajectory (currently only 'Hohmann' supported).
        *   `spacecraft_dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `engine_specific_impulse` (float): Engine's specific impulse (seconds).
        *   `**trajectory_args`: Additional keyword arguments passed to the trajectory planner (e.g., `launch_date`).
    *   **Outputs**:
        *   `float`: The calculated optimal fuel mass in kilograms.
    *   **Side Effects**:
        *   Raises `ValueError` for invalid inputs or calculation issues.
        *   Raises `RuntimeError` for unexpected errors during planning or calculation.
        *   Raises `ImportError` if critical dependencies are missing.
*   **Internal Logic**:
    *   Instantiates `TrajectoryPlanner`.
    *   Calls `planner.plan_trajectory` to get `total_delta_v`.
    *   Calls `calculate_fuel_mass_from_delta_v` (from `propulsion_system`) to compute fuel mass.

### 3. Dependencies
*   **`math`**: Standard Python mathematical functions (imported, though not explicitly used within this file's direct logic).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`).
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
## Purpose
This file implements a space travel calculator that determines the time, fuel requirements, and cost for a user to reach a chosen celestial destination, factoring in relativistic effects and orbital mechanics.

## Key Components
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: Travel time in the traveler's frame (years), average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years).
    *   **Side Effects**: Prints warnings for invalid speeds or calculation errors.
*   **`calc_age(years_travel_time, starting_age)`**:
    *   **Inputs**: Total travel time (years), user's starting age (int).
    *   **Outputs**: User's age upon arrival (float).
    *   **Side Effects**: Raises `ValueError` for non-positive or non-numeric inputs.
*   **`calc_arrival(departure_date, years_earth_frame)`**:
    *   **Inputs**: Departure date (`datetime`), travel time in Earth's frame (years).
    *   **Outputs**: Estimated arrival date (`datetime`) or `None` if calculation fails.
    *   **Side Effects**: Prints warnings/errors for date calculation issues.
*   **`convert_date(date_str)`**:
    *   **Inputs**: Date string in 'YYYY-MM-DD' format.
    *   **Outputs**: Converted `datetime` object.
*   **`main()`**:
    *   **Inputs**: None (gathers user input interactively from the console).
    *   **Outputs**: Prints a comprehensive travel summary to the console.
    *   **Side Effects**:
        *   Initializes `TrajectoryPlanner`.
        *   Retrieves celestial body data using `celestial_data`.
        *   Plans trajectory using `TrajectoryPlanner`.
        *   Optimizes fuel and calculates mass needed using `fuel_optimizer`.
        *   Calculates fuel cost using `fuel_calc`.
        *   Performs time dilation (`calc_time_earth`), age (`calc_age`), and arrival date (`calc_arrival`) calculations.
        *   Logs travel details using `travel_logger`.

## Dependencies
*   `math` (for mathematical operations like `sqrt`)
*   `datetime`, `timedelta` (for date and time manipulations)
*   `checks` (imported as `c`, likely for input validation)
*   `celestial_data` (for retrieving information about celestial bodies)
*   `orbital_mechanics` (imported but not directly called in `main`)
*   `trajectory_planner.TrajectoryPlanner` (for planning the spacecraft's path)
*   `propulsion_system` (imported but not directly called in `main`)
*   `fuel_calc` (for calculating fuel cost)
*   `travel_logger` (for saving travel details)
*   `constants.C_LIGHT_MPS` (for the speed of light constant)
*   `fuel_optimizer` (for calculating optimized fuel mass)
```

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for performing fundamental calculations related to orbital mechanics and 3D vector mathematics. It enables users to compute various orbital parameters, design transfers, and determine gravitational properties of celestial bodies.

### Key Components

*   **3D Vector Utility Functions**:
    *   `_validate_vector(vec, name)`: Internal helper for input validation.
    *   `vector_magnitude(vec)`: Calculates the Euclidean magnitude of a 3D vector.
        *   **Inputs**: `vec` (3-element tuple/list).
        *   **Outputs**: `float` (magnitude).
    *   `vector_subtract(vec1, vec2)`: Subtracts two 3D vectors.
        *   **Inputs**: `vec1`, `vec2` (3-element tuples).
        *   **Outputs**: `tuple` (resultant vector).
    *   `vector_add(vec1, vec2)`: Adds two 3D vectors.
        *   **Inputs**: `vec1`, `vec2` (3-element tuples).
        *   **Outputs**: `tuple` (resultant vector).
    *   `vector_scale(vec, scalar)`: Scales a 3D vector by a scalar.
        *   **Inputs**: `vec` (3-element tuple), `scalar` (float/int).
        *   **Outputs**: `tuple` (scaled vector).
    *   `vector_dot(vec1, vec2)`: Calculates the dot product of two 3D vectors.
        *   **Inputs**: `vec1`, `vec2` (3-element tuples).
        *   **Outputs**: `float` (dot product).
    *   `vector_cross(vec1, vec2)`: Calculates the cross product of two 3D vectors.
        *   **Inputs**: `vec1`, `vec2` (3-element tuples).
        *   **Outputs**: `tuple` (cross product vector).

*   **Existing Orbital Mechanics Functions**:
    *   `calculate_gravitational_parameter(central_body_name)`: Retrieves or calculates the gravitational parameter (mu) for a celestial body.
        *   **Inputs**: `central_body_name` (str).
        *   **Outputs**: `float` (gravitational parameter).
    *   `calculate_circular_orbital_velocity(mu, radius)`: Calculates velocity for a circular orbit.
        *   **Inputs**: `mu` (float), `radius` (float).
        *   **Outputs**: `float` (orbital velocity).
    *   `calculate_hohmann_transfer_delta_v(mu, r1, r2)`: Calculates Delta-V for a Hohmann transfer.
        *   **Inputs**: `mu` (float), `r1` (float), `r2` (float).
        *   **Outputs**: `tuple[float, float, float]` (Delta-V for burn 1, burn 2, and total).
    *   `calculate_hohmann_transfer_time_of_flight(mu, r1, r2)`: Calculates time of flight for a Hohmann transfer.
        *   **Inputs**: `mu` (float), `r1` (float), `r2` (float).
        *   **Outputs**: `float` (time of flight).
    *   `calculate_elliptical_orbital_period(mu, semi_major_axis)`: Calculates the orbital period using Kepler's Third Law.
        *   **Inputs**: `mu` (float), `semi_major_axis` (float).
        *   **Outputs**: `float` (orbital period).
    *   `calculate_escape_velocity(mu, radius)`: Calculates escape velocity from a central body.
        *   **Inputs**: `mu` (float), `radius` (float).
        *   **Outputs**: `float` (escape velocity).

*   **Universal Variable Lambert Solver Helper Functions**:
    *   `_stumpff_c(z)`, `_stumpff_s(z)`: Internal functions calculating Stumpff functions C(z) and S(z).
        *   **Inputs**: `z` (float).
        *   **Outputs**: `float`.
    *   `_calc_time_from_psi(psi, A_param, mu)`: Internal function to calculate time of flight given universal anomaly squared.
        *   **Inputs**: `psi` (float), `A_param` (float), `mu` (float).
        *   **Outputs**: `float` (time).
    *   `_calc_d_time_d_psi(psi, A_param, mu)`: Internal function for derivative of time with respect to psi.
        *   **Inputs**: `psi` (float), `A_param` (float), `mu` (float).
        *   **Outputs**: `float` (derivative).

*   **Lambert Solver Function**:
    *   `calculate_lambert_transfer(mu, r1_vec, r2_vec, delta_t)`: Calculates Delta-V for a Lambert transfer between two position vectors in a given time of flight using an iterative universal variable formulation.
        *   **Inputs**: `mu` (float), `r1_vec` (3-element tuple), `r2_vec` (3-element tuple), `delta_t` (float).
        *   **Outputs**: `tuple[float, float, float, float]` (Delta-V magnitude for burn 1, burn 2, total Delta-V, actual time of flight).

### Dependencies

*   `math`
*   `constants.G_GRAVITATIONAL`
*   `celestial_data.get_celestial_body_data`

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_orbital_mechanics.py`

This file, `tests/test_orbital_mechanics.py`, is a pytest suite designed to thoroughly test the functionalities of the `orbital_mechanics.py` module. It verifies various mathematical vector operations and core orbital mechanics calculations, ensuring they produce correct results and handle invalid inputs gracefully.

### Key Components

*   **Fixtures**:
    *   `mock_celestial_data()`: Patches `orbital_mechanics.celestial_data.get_celestial_body_data`.
        *   Inputs: None.
        *   Outputs: Yields a `MagicMock` configured to return predefined celestial body data (Sun, Earth, Mars, Moon) based on the input body name.
    *   `mock_ephemeris()`: Patches `orbital_mechanics.ephemeris.get_heliocentric_state`.
        *   Inputs: None.
        *   Outputs: Yields a `MagicMock` configured to return simplified heliocentric state data (distance and angular position) for Earth and Mars at a specific date.

*   **Vector Operations Tests (`test_vector_magnitude_`, `test_vector_subtract_`, etc.)**:
    *   Inputs: Numeric 3-element tuples or lists representing vectors, or a numeric scalar for `vector_scale`.
    *   Outputs: Assertions verify the correctness of the calculated vector magnitude, sum, difference, scaled vector, dot product, or cross product. They also assert that `ValueError` is raised for invalid input types, dimensions, or non-numeric elements.

*   **Orbital Mechanics Calculations Tests (`test_calculate_gravitational_parameter_`, `test_calculate_circular_orbital_velocity_`, `test_calculate_hohmann_transfer_delta_v_`, `test_calculate_hohmann_transfer_time_of_flight_`, `test_calculate_elliptical_orbital_period_`, `test_calculate_escape_velocity_`)**:
    *   Inputs: Gravitational parameter (mu), radii, semi-major axis, celestial body names, and sometimes a `datetime` object.
    *   Outputs: Assertions verify that the calculated orbital parameters (e.g., velocities, periods, delta-Vs) match expected values derived from orbital mechanics principles. They also check for `ValueError` when inputs are non-positive or data is missing/invalid.

*   **Internal Helper Function Test (`test_get_body_orbital_velocity_vector_`)**:
    *   Inputs: Celestial body name (string), `datetime` object, and gravitational parameter (float).
    *   Outputs: Asserts the correctness of the calculated orbital velocity vector (magnitude and direction) based on mocked ephemeris data, or raises `ValueError` if ephemeris data is unavailable or inputs are invalid.

*   **Simplified Lambert Transfer Test (`test_calculate_lambert_transfer_`)**:
    *   Inputs: Gravitational parameter (mu), initial and final position vectors (3-element tuples), and time of flight (float).
    *   Outputs: Asserts the magnitudes of the transfer velocity vectors at start/end and the total delta-V match expected values for a simplified Hohmann-like transfer. It also raises `ValueError` for invalid inputs, zero vectors, identical position vectors, or impossible transfer times.

### Dependencies

*   `pytest`: Testing framework.
*   `math`: For mathematical functions like `sqrt`, `pi`, `sin`, `cos`.
*   `datetime`, `timedelta` (from `datetime` module): For handling dates and time differences.
*   `unittest.mock.patch`, `unittest.mock.MagicMock`: For mocking external function calls.
*   `orbital_mechanics`: The module under test, from which various functions are imported.
*   `celestial_data`: Imported for the purpose of mocking its `get_celestial_body_data` function.
*   `constants`: Imported, but not directly used in the provided content.

---


## `tests/test_trajectory_planner.py`

This file contains unit tests for the `TrajectoryPlanner` class. It uses pytest and unittest.mock to isolate the `TrajectoryPlanner` logic by mocking its external dependencies, ensuring that initialization and trajectory planning methods (Hohmann, Direct/Lambert) behave as expected, including various success and failure scenarios.

### Key Components:

*   **`_parse_date_string` (Helper Function)**:
    *   **Inputs**: `date_str` (string in 'YYYY-MM-DD' format).
    *   **Outputs**: A `datetime.datetime` object.
*   **`mock_celestial_data_for_planner` (Fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Patches `trajectory_planner.celestial_data.get_celestial_body_data` to return predefined data for Sun, Earth, Mars, and Moon.
*   **`mock_orbital_mechanics` (Fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Patches several functions within `trajectory_planner.orbital_mechanics` (`calculate_hohmann_transfer_delta_v`, `calculate_hohmann_transfer_time_of_flight`, `calculate_lambert_transfer`, `calculate_gravitational_parameter`). The `calculate_lambert_transfer` mock simulates an iterative solver with an optimal time window.
*   **`mock_ephemeris_get_heliocentric_state` (Fixture)**:
    *   **Inputs**: None.
    *   **Outputs/Side Effects**: Patches `trajectory_planner.ephemeris.get_heliocentric_state` to provide illustrative heliocentric positions for Earth and Mars on specific dates.
*   **Test Functions (`test_trajectory_planner_init_*`, `test_plan_hohmann_trajectory_*`, `test_plan_direct_transfer_*`, `test_plan_trajectory_*`)**:
    *   **Inputs**: Utilizes the above-mentioned fixtures.
    *   **Outputs/Side Effects**: Assertions verify `TrajectoryPlanner`'s initialization (`mu_sun` loading, error handling), successful planning for Hohmann and Direct transfers (correct delta-v, travel time, dependency calls), fallback mechanisms (ephemeris to static data), and robust error handling for unsupported bodies, calculation errors, or invalid inputs. Specific tests cover scenarios like identical departure/arrival bodies for direct transfers.

### Dependencies:

*   `pytest`: For test structuring and execution.
*   `unittest.mock`: For creating mock objects and patching modules/functions.
*   `datetime`, `timedelta`: For date and time manipulation in tests.
*   `math`: For mathematical operations like `pi` and `isclose`.
*   `trajectory_planner`: The main module under test.
*   `celestial_data`, `orbital_mechanics`, `ephemeris`, `constants`: Modules that `TrajectoryPlanner` depends on, which are extensively mocked in these tests.

---


## `trajectory_planner.py`

```markdown
**Purpose**
This file defines the `TrajectoryPlanner` class, which provides a high-level interface for planning interplanetary trajectories by orchestrating calls to orbital mechanics, celestial data, and ephemeris modules to calculate details like total delta-v and travel time for various transfer types.

**Key Components**
*   **Class: `TrajectoryPlanner`**
    *   **Inputs**: Initialized without parameters, but its methods take celestial body names, departure dates, and trajectory types.
    *   **Outputs/Side Effects**: Stores the Sun's gravitational parameter; its methods return dictionaries containing trajectory calculation results or error messages.
*   **Method: `__init__(self)`**
    *   **Inputs**: None (besides `self`).
    *   **Outputs/Side Effects**: Fetches the Sun's gravitational parameter (`mu_sun`) from `celestial_data` and stores it, raising errors if data is missing or invalid.
*   **Method: `_plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime) -> dict`**
    *   **Inputs**: Names of departure and arrival bodies (strings), and a departure date (datetime object).
    *   **Outputs**: A dictionary with details for a Hohmann transfer, including delta-v, travel time, and dynamic orbital distances, or an error dictionary.
*   **Method: `_plan_direct_transfer(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime) -> dict`**
    *   **Inputs**: Names of departure and arrival bodies (strings), and a departure date (datetime object).
    *   **Outputs**: A dictionary with details for a direct transfer (using a simplified Lambert's problem solver that iterates through flight times to find optimal delta-v), or an error dictionary.
*   **Method: `plan_trajectory(self, departure_body_name: str, arrival_body_name: str, trajectory_type: str = 'Hohmann', **kwargs) -> dict`**
    *   **Inputs**: Names of departure and arrival bodies (strings), trajectory type (string, 'Hohmann' or 'Direct'), and `kwargs` requiring `departure_date` (string 'YYYY-MM-DD').
    *   **Outputs**: Dispatches to the appropriate private planning method (`_plan_hohmann_trajectory` or `_plan_direct_transfer`) and returns its results, or an error dictionary for unsupported types or invalid input.

**Dependencies**
*   `math`
*   `datetime` (from `datetime` module)
*   `timedelta` (from `datetime` module)
*   `orbital_mechanics` (local module)
*   `celestial_data` (local module)
*   `ephemeris` (local module)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
