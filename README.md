# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 23

**Last Updated:** 2025-11-18 22:51:18

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

```markdown
## Analysis of `celestial_data.py`

### Purpose
This module serves as the definitive source for astrophysical data within the `space_travel_calculator` application, centralizing detailed parameters for solar system celestial bodies. It provides functions to retrieve this data and list potential destinations, while also re-exporting universal physical constants for consistency.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: Global constant re-exported from `constants`, representing the Gravitational Constant (m³ kg⁻¹ s⁻²).
*   **`SPEED_OF_LIGHT`**: Global constant re-exported from `constants`, representing the Speed of Light (m/s).
*   **`CELESTIAL_BODIES_DATA`**: A dictionary containing detailed astrophysical data for various celestial bodies (e.g., mass, radius, gravitational parameter, semi-major axis from Sun, orbital period).
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Inputs**: `body_name` (string, case-insensitive name of a celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Inputs**: None.
    *   **Outputs**: A list of dictionaries, each with 'name' and calculated 'distance' from Earth (in meters), sorted by distance. Returns `None` if Earth's data is missing.

### Dependencies
*   **`math`**: Used for `math.fabs()` in distance calculations.
*   **`constants`**: Imports `G_GRAVITATIONAL` (as `GRAVITATIONAL_CONSTANT`) and `C_LIGHT_MPS` (as `SPEED_OF_LIGHT`).
```

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `ephemeris.py`

This file, `ephemeris.py`, provides functions to calculate the approximate heliocentric orbital state (distance and angular position) of celestial bodies using a simplified circular orbit model based on Kepler's Third Law. It serves as a basic ephemeris calculator, specifically excluding the Sun and Earth's Moon from its direct calculations.

### Key Components:

*   **`J2000_EPOCH`**: A constant `datetime.datetime` object representing the J2000.0 epoch in UTC.
*   **`_get_mu_sun()`**:
    *   **Inputs**: None.
    *   **Outputs**: Returns the Sun's gravitational parameter (μ) as a `float` (m^3/s^2), caching the value for efficiency. Raises `ValueError` if the parameter cannot be retrieved.
*   **`get_heliocentric_state(body_name: str, date: datetime.datetime)`**:
    *   **Inputs**: `body_name` (string, e.g., 'Mars'), `date` (timezone-aware or naive `datetime.datetime` object).
    *   **Outputs**: Returns a `dict` containing `"distance_from_sun_m"` (float) and `"angular_position_rad"` (float, 0 to 2π). Raises `ValueError` for invalid inputs, unsupported bodies (Sun, Moon), or missing data.
*   **`if __name__ == '__main__':`**:
    *   **Purpose**: Contains a self-test suite demonstrating the usage of `get_heliocentric_state` with various valid and invalid inputs, printing the results and caught errors.

### Dependencies:

*   `math`
*   `datetime`
*   `celestial_data` (for `get_celestial_body_data`)
*   `orbital_mechanics` (for `calculate_gravitational_parameter`, `calculate_elliptical_orbital_period`)

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## fuel_optimizer.py

### 1. Purpose
This file orchestrates the calculation of optimal fuel mass required for a spacecraft's trajectory. It integrates a trajectory planner to determine the necessary delta-V and then uses a propulsion system model to compute the fuel mass based on that delta-V and engine parameters.

### 2. Key Components
*   **`optimize_fuel_for_trajectory` function**:
    *   **Inputs**:
        *   `start_body` (str): Origin celestial body.
        *   `end_body` (str): Target celestial body.
        *   `trajectory_type` (str): The type of trajectory (currently only 'Hohmann' supported).
        *   `spacecraft_dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `engine_specific_impulse` (float): Engine's specific impulse (seconds).
        *   `**trajectory_args`: Additional keyword arguments passed to the trajectory planner (e.g., `launch_date`).
    *   **Outputs**:
        *   `float`: The calculated optimal fuel mass in kilograms.
    *   **Side Effects**:
        *   Raises `ValueError` for invalid inputs or calculation issues.
        *   Raises `RuntimeError` for unexpected errors during planning or calculation.
        *   Raises `ImportError` if critical dependencies are missing.
*   **Internal Logic**:
    *   Instantiates `TrajectoryPlanner`.
    *   Calls `planner.plan_trajectory` to get `total_delta_v`.
    *   Calls `calculate_fuel_mass_from_delta_v` (from `propulsion_system`) to compute fuel mass.

### 3. Dependencies
*   **`math`**: Standard Python mathematical functions (imported, though not explicitly used within this file's direct logic).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`).
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

This Python script (`main.py`) serves as a space travel calculator that determines the time, fuel, and cost required for a user to reach a chosen celestial destination, incorporating relativistic effects, orbital mechanics, and fuel requirements based on user inputs.

### Key Components

*   **`main()` function**:
    *   **Inputs**: Interactive user inputs for departure/arrival bodies, spacecraft dry mass, engine specific impulse, departure date, user age, and fuel price per unit.
    *   **Outputs/Side Effects**: Prints a detailed travel summary to the console and logs travel details using `travel_logger`. It orchestrates all other calculations.
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: Travel time in the traveler's frame (years) and average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years), accounting for relativistic time dilation. Returns `float('inf')` for zero speed or traveler's time on error/invalid speed.
*   **`calc_age(years_travel_time, starting_age)`**:
    *   **Inputs**: Total travel time (years) and the user's starting age.
    *   **Outputs**: The user's calculated age upon arrival.
*   **`calc_arrival(departure_date, years_earth_frame)`**:
    *   **Inputs**: The departure `datetime` object and travel time in Earth's frame (years).
    *   **Outputs**: An estimated arrival `datetime` object, or `None` if the calculation fails or results in an out-of-range date.
*   **`convert_date(date_str)`**:
    *   **Inputs**: A date string in 'YYYY-MM-DD' format.
    *   **Outputs**: A `datetime` object representing the parsed date.
*   **Sections within `main()`**:
    *   **Input Collection**: Gathers and validates all necessary user inputs for the calculation.
    *   **Trajectory Planning**: Uses `TrajectoryPlanner` to determine required Delta-V, travel time (traveler's frame), and transfer type.
    *   **Fuel Calculation**: Employs `fuel_optimizer` and `fuel_calc` to compute the total fuel mass needed and its corresponding cost.
    *   **Time and Age Calculations**: Utilizes the custom `calc_time_earth`, `calc_age`, and `calc_arrival` functions to compute relativistic travel time, user's arrival age, and estimated arrival date.
    *   **Output Summary**: Presents all calculated results in a formatted output to the user.
    *   **Log Travel Details**: Records the key parameters of the simulated journey using the `travel_logger` module.

### Dependencies

*   `math`
*   `datetime` (from `datetime`)
*   `timedelta` (from `datetime`)
*   `checks as c` (local module for input validation)
*   `celestial_data` (local module for celestial body information)
*   `orbital_mechanics` (local module, `calculate_circular_orbital_velocity` is imported but not directly used in `main`)
*   `trajectory_planner` (local module, provides `TrajectoryPlanner` class)
*   `propulsion_system` (local module, imported but not directly used in `main`)
*   `fuel_calc` (local module for fuel cost calculations)
*   `travel_logger` (local module for logging travel details)
*   `constants` (local module, specifically `C_LIGHT_MPS`)
*   `fuel_optimizer` (local module for optimizing fuel calculations)

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_fuel_optimizer.py`

This file contains unit tests for the `optimize_fuel_for_trajectory` function within the `fuel_optimizer` module, using `pytest` for testing and `unittest.mock` for dependency mocking.

### Purpose
The purpose of this file is to thoroughly test the `optimize_fuel_for_trajectory` function, verifying its correct behavior under various conditions, including successful execution, invalid inputs, and error propagation from its dependencies (`TrajectoryPlanner` and a fuel calculation function from `propulsion_system`).

### Key Components

*   **`mock_dependencies_for_fuel_optimizer` (pytest fixture)**
    *   **Inputs**: None (a pytest fixture).
    *   **Outputs**: A dictionary containing mocked instances of `TrajectoryPlanner` and the `calculate_fuel_mass_from_delta_v` function (aliased in `fuel_optimizer`), pre-configured with default successful return values.
    *   **Side Effects**: Patches `fuel_optimizer.TrajectoryPlanner` and `fuel_optimizer.calculate_fuel_mass_from_delta_v` using `unittest.mock.patch`.
*   **`test_optimize_fuel_for_trajectory_success`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that `optimize_fuel_for_trajectory` returns the expected fuel mass and that its internal dependencies (`TrajectoryPlanner.plan_trajectory` and the fuel mass calculation) were called exactly once with the correct arguments.
*   **`test_optimize_fuel_for_trajectory_unsupported_trajectory_type`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised when an unsupported trajectory type is provided, and that no mocked dependencies were called.
*   **`test_optimize_fuel_for_trajectory_invalid_inputs` (parameterized)**
    *   **Inputs**: `dry_mass`, `specific_impulse`, `expected_error` (from `pytest.mark.parametrize`).
    *   **Outputs**: Asserts that a `ValueError` is raised for various invalid inputs (e.g., non-positive dry mass or specific impulse, non-numeric values).
*   **`test_optimize_fuel_for_trajectory_planner_returns_unsuccessful`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a failure status.
*   **`test_optimize_fuel_for_trajectory_planner_returns_invalid_delta_v`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a negative `total_delta_v`.
*   **`test_optimize_fuel_for_trajectory_propulsion_system_raises_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (wrapped) is raised if the mocked fuel calculation function itself raises an error.
*   **`test_optimize_fuel_for_trajectory_propulsion_returns_negative_fuel`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if the mocked fuel calculation function returns a negative fuel mass.
*   **`test_optimize_fuel_for_trajectory_planner_raises_runtime_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `RuntimeError` (wrapped) is raised if `TrajectoryPlanner.plan_trajectory` raises an unexpected `RuntimeError`.
*   **`test_optimize_fuel_for_trajectory_planner_raises_type_error_with_kwargs`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (indicating a signature mismatch) is raised if `TrajectoryPlanner.plan_trajectory` raises a `TypeError`, such as from receiving unexpected keyword arguments.

### Dependencies

*   `pytest`: Test framework.
*   `unittest.mock.MagicMock`: For creating mock objects.
*   `unittest.mock.patch`: For temporarily replacing objects with mocks.
*   `fuel_optimizer`: The module under test, specifically importing `optimize_fuel_for_trajectory` and `TrajectoryPlanner`.

---


## `tests/test_main.py`

This file, `tests/test_main.py`, is a comprehensive Pytest suite designed to test the `main.py` application. Its primary purpose is to verify the correct integration of various modules within `main.py` and ensure robust error handling under different failure scenarios, as well as to test specific helper functions.

### Key Components

*   **`mock_dependencies` (Pytest Fixture)**:
    *   **Inputs**: None directly, but it patches numerous functions and classes from `main.py`'s dependencies (`celestial_data`, `trajectory_planner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `builtins.input`, `builtins.print`, `main.c`).
    *   **Outputs/Side Effects**: Yields a dictionary of configured mock objects, allowing test functions to interact with and assert calls on these mocks. It sets up `side_effect` and `return_value` for various mocked functions to simulate different system behaviors.
*   **`test_main_function_integrates_all_components_correctly` (Test Function)**:
    *   **Inputs**: Uses the `mock_dependencies` fixture and simulates user input via `mock_input`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that all mocked external functions are called with expected arguments, and that `main.main()` produces the correct output messages via `mock_print` and logs travel details via `mock_save_travel_log`. It specifically checks relativistic time calculations, estimated arrival dates, and age calculations.
*   **Error Handling Test Functions (e.g., `test_main_function_trajectory_planner_fails`, `test_main_function_fuel_optimizer_raises_value_error`)**:
    *   **Inputs**: Use `mock_dependencies` and `mock_input`, but configure specific mocks to simulate failures (e.g., `return_value={'success': False}` or `side_effect=ValueError`).
    *   **Outputs/Side Effects**: Call `main.main()` and assert that appropriate error messages are printed via `mock_print`, and that subsequent processing steps (like fuel optimization or logging) are not called.
*   **Helper Function Test Cases (e.g., `test_calc_time_earth_relativistic_zero_speed`, `test_calc_age_valid_inputs`, `test_calc_arrival_valid_inputs`, `test_convert_date_valid`)**:
    *   **Inputs**: Direct arguments to `main.calc_time_earth`, `main.calc_age`, `main.calc_arrival`, `main.convert_date`.
    *   **Outputs/Side Effects**: Assert the correctness of the return values for various valid and edge-case inputs, including checking for specific warnings printed and `ValueError` exceptions raised for invalid inputs.
*   **`test_main_function_average_speed_fallback` (Test Function)**:
    *   **Inputs**: Uses `mock_dependencies` and `mock_input`, specifically mocking a zero `average_hohmann_speed_ms`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that a warning is printed regarding the fallback speed, and that `mock_save_travel_log` is called with the expected fallback speed (0.1% of C).

### Dependencies

*   `pytest`: For the testing framework and fixtures.
*   `unittest.mock.patch`, `MagicMock`, `call`: For mocking external dependencies and internal functions.
*   `datetime.datetime`, `timedelta`: For date and time calculations and assertions.
*   `math`: For mathematical operations like `sqrt` in relativistic calculations.
*   `sys`: Imported but not directly used in the provided snippet.
*   `main`: The module under test.
*   `constants.C_LIGHT_MPS`: A specific constant used in relativistic calculations.

---


## `tests/test_trajectory_planner.py`

This file contains unit tests for the `TrajectoryPlanner` class, verifying its initialization and the `plan_trajectory` method, specifically focusing on Hohmann transfers. It uses mock objects to isolate `TrajectoryPlanner` from its dependencies and tests various scenarios, including successful planning, input validation, error handling, and the system's reliance on dynamic (ephemeris) versus static celestial data.

### Key Components:

*   **`mock_celestial_data_for_planner` (fixture)**
    *   **Inputs:** None (patches `trajectory_planner.celestial_data.get_celestial_body_data`).
    *   **Outputs/Side Effects:** Mocks the `get_celestial_body_data` function to return predefined dictionary data for celestial bodies like Sun, Earth, Mars, and Jupiter.
*   **`mock_orbital_mechanics` (fixture)**
    *   **Inputs:** None (patches `trajectory_planner.orbital_mechanics.calculate_hohmann_transfer_delta_v` and `calculate_hohmann_transfer_time_of_flight`).
    *   **Outputs/Side Effects:** Mocks these orbital mechanics functions to return fixed delta-V and time-of-flight values.
*   **`mock_ephemeris_get_body_orbital_state` (fixture)**
    *   **Inputs:** None (patches `trajectory_planner.ephemeris.get_body_orbital_state`).
    *   **Outputs/Side Effects:** Mocks the `get_body_orbital_state` function to return simulated `distance_from_sun_m` data for specific bodies and dates.
*   **`test_trajectory_planner_init_*` functions**
    *   **Inputs:** `mock_celestial_data_for_planner` fixture.
    *   **Outputs/Side Effects:** Instantiate `TrajectoryPlanner` and assert correct initialization (`mu_sun` value) or raise expected `ValueError` or `AttributeError` for invalid or missing Sun data.
*   **`test_plan_trajectory_hohmann_*` functions**
    *   **Inputs:** Departure/arrival body names (strings), `trajectory_type` (string, defaults to "Hohmann"), optional `departure_date` (datetime object). These tests use the various mock fixtures.
    *   **Outputs/Side Effects:** Call `planner.plan_trajectory` and assert the `success` status, resulting `delta_v` and `travel_time` (including formatted string), and error messages. They also verify that the correct mock functions were called with appropriate arguments (e.g., ephemeris data used if available, fallback to static data if not, or failure if both are insufficient).
*   **`test_plan_trajectory_default_type_hohmann_with_date`, `test_plan_trajectory_unsupported_type_with_date`, `test_plan_trajectory_invalid_type_non_string_with_date` functions**
    *   **Inputs:** Similar to `test_plan_trajectory_hohmann_*` but with varying `trajectory_type` parameters.
    *   **Outputs/Side Effects:** Verify the default behavior when `trajectory_type` is not specified, and proper error handling for unsupported or invalid trajectory types.

### Dependencies:

*   `pytest`: Testing framework.
*   `unittest.mock.patch`, `MagicMock`, `call`: For mocking dependencies.
*   `datetime.timedelta`, `datetime.datetime`: Date and time objects.
*   `math`: (Implicitly used by patched modules, not directly in test code).
*   `trajectory_planner`: The module containing the `TrajectoryPlanner` class under test.
*   `celestial_data`: Mocked module.
*   `orbital_mechanics`: Mocked module.
*   `constants`: (Imported, but not directly used in these tests).
*   `ephemeris`: (Implicitly mocked via `trajectory_planner.ephemeris`).

---


## `trajectory_planner.py`

```markdown
### Purpose
This file defines the `TrajectoryPlanner` class, which provides a high-level interface for planning interplanetary trajectories, specifically Hohmann transfers. It orchestrates calls to orbital mechanics functions and uses an ephemeris to dynamically determine orbital positions based on a departure date, returning details like total delta-v and travel time.

### Key Components

*   **`TrajectoryPlanner` Class**:
    *   **`__init__(self)`**:
        *   **Inputs**: None directly; retrieves Sun's gravitational parameter from `celestial_data`.
        *   **Outputs/Side Effects**: Initializes `self.mu_sun`. Raises `ValueError` or `AttributeError` if Sun data is invalid or missing.
    *   **`_plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str, departure_date: str) -> dict`**:
        *   **Inputs**: Departure body name (string), arrival body name (string), and departure date (string in 'YYYY-MM-DD' format).
        *   **Outputs**: A dictionary containing transfer details: `departure_body`, `arrival_body`, `transfer_type`, `total_delta_v_mps`, `travel_time_days`, `travel_time_h_m_s`, `success` (boolean), `error` (string or None), `departure_distance_from_sun_m`, `arrival_distance_from_sun_m`.
        *   **Role**: Calculates a Hohmann transfer, dynamically fetching orbital distances from `ephemeris` for the specified date and then using `orbital_mechanics` to compute delta-v and travel time.
    *   **`plan_trajectory(self, departure_body_name: str, arrival_body_name: str, trajectory_type: str = 'Hohmann', **kwargs) -> dict`**:
        *   **Inputs**: Departure body name (string), arrival body name (string), `trajectory_type` (string, defaults to 'Hohmann'), and `kwargs` which must include `departure_date` for Hohmann transfers.
        *   **Outputs**: A dictionary with trajectory details (same structure as `_plan_hohmann_trajectory`).
        *   **Role**: Acts as a public dispatcher, validating inputs and calling the appropriate private planning method (currently only `_plan_hohmann_trajectory`).
*   **`if __name__ == '__main__':` block**:
    *   **Role**: Contains example usage of the `TrajectoryPlanner` class, demonstrating successful trajectory planning and various error handling scenarios.

### Dependencies
*   `math`
*   `datetime.timedelta`
*   `orbital_mechanics` (local module)
*   `celestial_data` (local module)
*   `ephemeris` (local module)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
