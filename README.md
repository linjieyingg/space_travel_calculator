# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 23

**Last Updated:** 2025-11-18 23:00:20

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

```markdown
## Analysis of `celestial_data.py`

### Purpose
This module serves as the definitive source for astrophysical data within the `space_travel_calculator` application, centralizing detailed parameters for solar system celestial bodies. It provides functions to retrieve this data and list potential destinations, while also re-exporting universal physical constants for consistency.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: Global constant re-exported from `constants`, representing the Gravitational Constant (m³ kg⁻¹ s⁻²).
*   **`SPEED_OF_LIGHT`**: Global constant re-exported from `constants`, representing the Speed of Light (m/s).
*   **`CELESTIAL_BODIES_DATA`**: A dictionary containing detailed astrophysical data for various celestial bodies (e.g., mass, radius, gravitational parameter, semi-major axis from Sun, orbital period).
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Inputs**: `body_name` (string, case-insensitive name of a celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Inputs**: None.
    *   **Outputs**: A list of dictionaries, each with 'name' and calculated 'distance' from Earth (in meters), sorted by distance. Returns `None` if Earth's data is missing.

### Dependencies
*   **`math`**: Used for `math.fabs()` in distance calculations.
*   **`constants`**: Imports `G_GRAVITATIONAL` (as `GRAVITATIONAL_CONSTANT`) and `C_LIGHT_MPS` (as `SPEED_OF_LIGHT`).
```

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `ephemeris.py`

This Python file, `ephemeris.py`, calculates the approximate heliocentric (Sun-centered) orbital state (distance and angular position) for celestial bodies using a simplified circular orbit model based on Kepler's laws. It provides a foundational mechanism for basic astronomical position estimations for planets.

### Key Components:

*   **`J2000_EPOCH`**: A `datetime.datetime` constant representing the J2000.0 epoch in UTC, used as a reference for time difference calculations.
*   **`_get_mu_sun()`**:
    *   **Inputs**: None.
    *   **Outputs**: Returns the Sun's gravitational parameter (mu) as a float (m^3/s^2), internally caching the result for efficiency. Raises `ValueError` if the parameter cannot be retrieved or is invalid.
*   **`get_heliocentric_state(body_name: str, date: datetime.datetime)`**:
    *   **Inputs**:
        *   `body_name` (str): The case-insensitive name of a celestial body (e.g., 'Mars').
        *   `date` (datetime.datetime): The specific date and time (timezone-aware recommended, naive dates are converted to UTC).
    *   **Outputs**: A dictionary containing:
        *   `"distance_from_sun_m"` (float): Approximate distance from the Sun in meters.
        *   `"angular_position_rad"` (float): Approximate angular position in radians (0 to 2*pi).
    *   **Side Effects**: Raises `ValueError` for invalid inputs, missing celestial data, or if the calculation is requested for the Sun or Moon (which are explicitly not supported by this simplified model).
*   **`if __name__ == '__main__':`**:
    *   **Purpose**: Contains a comprehensive self-test suite demonstrating the `get_heliocentric_state` function with valid inputs, invalid inputs, edge cases (past dates, naive datetimes), and unsupported bodies, printing results and caught errors.

### Dependencies:

*   `math`
*   `datetime`
*   `celestial_data` (specifically `get_celestial_body_data`)
*   `orbital_mechanics` (specifically `calculate_gravitational_parameter`, `calculate_elliptical_orbital_period`)

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## fuel_optimizer.py

### 1. Purpose
This file orchestrates the calculation of optimal fuel mass required for a spacecraft's trajectory. It integrates a trajectory planner to determine the necessary delta-V and then uses a propulsion system model to compute the fuel mass based on that delta-V and engine parameters.

### 2. Key Components
*   **`optimize_fuel_for_trajectory` function**:
    *   **Inputs**:
        *   `start_body` (str): Origin celestial body.
        *   `end_body` (str): Target celestial body.
        *   `trajectory_type` (str): The type of trajectory (currently only 'Hohmann' supported).
        *   `spacecraft_dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `engine_specific_impulse` (float): Engine's specific impulse (seconds).
        *   `**trajectory_args`: Additional keyword arguments passed to the trajectory planner (e.g., `launch_date`).
    *   **Outputs**:
        *   `float`: The calculated optimal fuel mass in kilograms.
    *   **Side Effects**:
        *   Raises `ValueError` for invalid inputs or calculation issues.
        *   Raises `RuntimeError` for unexpected errors during planning or calculation.
        *   Raises `ImportError` if critical dependencies are missing.
*   **Internal Logic**:
    *   Instantiates `TrajectoryPlanner`.
    *   Calls `planner.plan_trajectory` to get `total_delta_v`.
    *   Calls `calculate_fuel_mass_from_delta_v` (from `propulsion_system`) to compute fuel mass.

### 3. Dependencies
*   **`math`**: Standard Python mathematical functions (imported, though not explicitly used within this file's direct logic).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`).
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

## Purpose
This file `main.py` is the core execution script for a space travel calculator. It gathers user input for a celestial journey, calculates travel time (accounting for relativistic effects), user's age upon arrival, fuel requirements, and estimated arrival date, then provides a summary and logs the travel details.

## Key Components

### `calc_time_earth`
*   **Inputs**: `years_traveler_frame` (float, travel time in traveler's reference frame), `average_speed_ms` (float, average speed in m/s).
*   **Outputs**: `float` representing travel time in Earth's reference frame in years.
*   **Side Effects**: Prints warnings for invalid or relativistic speeds.

### `calc_age`
*   **Inputs**: `years_travel_time` (float, total travel time), `starting_age` (int, user's current age).
*   **Outputs**: `float` representing the user's age upon arrival.
*   **Side Effects**: Raises `ValueError` for non-positive or non-numeric inputs.

### `calc_arrival`
*   **Inputs**: `departure_date` (datetime object), `years_earth_frame` (float, total travel years in Earth's frame).
*   **Outputs**: `datetime` object representing the estimated arrival date, or `None` if calculation fails.
*   **Side Effects**: Prints warnings/errors if the date calculation results in an overflow or invalid input.

### `convert_date`
*   **Inputs**: `date_str` (string in 'YYYY-MM-DD' format).
*   **Outputs**: `datetime` object.

### `main()` function
*   **Inputs**: Interactive user inputs from console for destination, spacecraft parameters (dry mass, engine specific impulse), departure date, user's age, and fuel price.
*   **Outputs**: Prints a detailed travel summary to the console, including required Delta-V, fuel mass, fuel cost, travel times (traveler's and Earth's frames), arrival age, and estimated arrival date.
*   **Side Effects**: Orchestrates the entire calculation flow, calls various modules (`TrajectoryPlanner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `celestial_data`, `checks`), and attempts to save travel details to a log.

## Dependencies
*   `math`
*   `datetime`, `timedelta` (from `datetime` module)
*   `checks as c` (local module for input validation)
*   `celestial_data` (local module for celestial body information)
*   `orbital_mechanics` (local module, imported but not directly used in `main`)
*   `trajectory_planner.TrajectoryPlanner` (local module for trajectory calculations)
*   `propulsion_system` (local module, imported but not directly used in `main`)
*   `fuel_calc` (local module for fuel cost calculations)
*   `travel_logger` (local module for saving travel logs)
*   `constants.C_LIGHT_MPS` (local module for physical constants)
*   `fuel_optimizer` (local module for optimizing fuel calculations)

---


## `orbital_mechanics.py`

This file, `orbital_mechanics.py`, provides a suite of functions for calculating fundamental parameters and maneuvers in orbital mechanics. It covers calculations for gravitational parameters, orbital velocities, Hohmann transfer specifics, orbital periods, and escape velocity.

### Key Components:

*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body (e.g., "Earth").
    *   **Outputs**: The standard gravitational parameter (mu) for the specified body in m^3/s^2.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the radius of a circular orbit.
    *   **Outputs**: The velocity required for a stable circular orbit in m/s.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer in m/s.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu), and the radii of the initial (r1) and final (r2) circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer in seconds.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the semi-major axis of an elliptical orbit.
    *   **Outputs**: The orbital period in seconds.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter (mu) and the distance from its center.
    *   **Outputs**: The escape velocity from that radius in m/s.

### Dependencies:

*   `math`: For mathematical functions like `sqrt` and `pi`.
*   `constants.G_GRAVITATIONAL`: Imports the universal gravitational constant.
*   `celestial_data.get_celestial_body_data`: Imports a function to retrieve data about celestial bodies.

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_fuel_optimizer.py`

This file contains unit tests for the `optimize_fuel_for_trajectory` function within the `fuel_optimizer` module, using `pytest` for testing and `unittest.mock` for dependency mocking.

### Purpose
The purpose of this file is to thoroughly test the `optimize_fuel_for_trajectory` function, verifying its correct behavior under various conditions, including successful execution, invalid inputs, and error propagation from its dependencies (`TrajectoryPlanner` and a fuel calculation function from `propulsion_system`).

### Key Components

*   **`mock_dependencies_for_fuel_optimizer` (pytest fixture)**
    *   **Inputs**: None (a pytest fixture).
    *   **Outputs**: A dictionary containing mocked instances of `TrajectoryPlanner` and the `calculate_fuel_mass_from_delta_v` function (aliased in `fuel_optimizer`), pre-configured with default successful return values.
    *   **Side Effects**: Patches `fuel_optimizer.TrajectoryPlanner` and `fuel_optimizer.calculate_fuel_mass_from_delta_v` using `unittest.mock.patch`.
*   **`test_optimize_fuel_for_trajectory_success`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that `optimize_fuel_for_trajectory` returns the expected fuel mass and that its internal dependencies (`TrajectoryPlanner.plan_trajectory` and the fuel mass calculation) were called exactly once with the correct arguments.
*   **`test_optimize_fuel_for_trajectory_unsupported_trajectory_type`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised when an unsupported trajectory type is provided, and that no mocked dependencies were called.
*   **`test_optimize_fuel_for_trajectory_invalid_inputs` (parameterized)**
    *   **Inputs**: `dry_mass`, `specific_impulse`, `expected_error` (from `pytest.mark.parametrize`).
    *   **Outputs**: Asserts that a `ValueError` is raised for various invalid inputs (e.g., non-positive dry mass or specific impulse, non-numeric values).
*   **`test_optimize_fuel_for_trajectory_planner_returns_unsuccessful`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a failure status.
*   **`test_optimize_fuel_for_trajectory_planner_returns_invalid_delta_v`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a negative `total_delta_v`.
*   **`test_optimize_fuel_for_trajectory_propulsion_system_raises_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (wrapped) is raised if the mocked fuel calculation function itself raises an error.
*   **`test_optimize_fuel_for_trajectory_propulsion_returns_negative_fuel`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if the mocked fuel calculation function returns a negative fuel mass.
*   **`test_optimize_fuel_for_trajectory_planner_raises_runtime_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `RuntimeError` (wrapped) is raised if `TrajectoryPlanner.plan_trajectory` raises an unexpected `RuntimeError`.
*   **`test_optimize_fuel_for_trajectory_planner_raises_type_error_with_kwargs`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (indicating a signature mismatch) is raised if `TrajectoryPlanner.plan_trajectory` raises a `TypeError`, such as from receiving unexpected keyword arguments.

### Dependencies

*   `pytest`: Test framework.
*   `unittest.mock.MagicMock`: For creating mock objects.
*   `unittest.mock.patch`: For temporarily replacing objects with mocks.
*   `fuel_optimizer`: The module under test, specifically importing `optimize_fuel_for_trajectory` and `TrajectoryPlanner`.

---


## `tests/test_main.py`

This file, `tests/test_main.py`, is a comprehensive Pytest suite designed to test the `main.py` application. Its primary purpose is to verify the correct integration of various modules within `main.py` and ensure robust error handling under different failure scenarios, as well as to test specific helper functions.

### Key Components

*   **`mock_dependencies` (Pytest Fixture)**:
    *   **Inputs**: None directly, but it patches numerous functions and classes from `main.py`'s dependencies (`celestial_data`, `trajectory_planner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `builtins.input`, `builtins.print`, `main.c`).
    *   **Outputs/Side Effects**: Yields a dictionary of configured mock objects, allowing test functions to interact with and assert calls on these mocks. It sets up `side_effect` and `return_value` for various mocked functions to simulate different system behaviors.
*   **`test_main_function_integrates_all_components_correctly` (Test Function)**:
    *   **Inputs**: Uses the `mock_dependencies` fixture and simulates user input via `mock_input`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that all mocked external functions are called with expected arguments, and that `main.main()` produces the correct output messages via `mock_print` and logs travel details via `mock_save_travel_log`. It specifically checks relativistic time calculations, estimated arrival dates, and age calculations.
*   **Error Handling Test Functions (e.g., `test_main_function_trajectory_planner_fails`, `test_main_function_fuel_optimizer_raises_value_error`)**:
    *   **Inputs**: Use `mock_dependencies` and `mock_input`, but configure specific mocks to simulate failures (e.g., `return_value={'success': False}` or `side_effect=ValueError`).
    *   **Outputs/Side Effects**: Call `main.main()` and assert that appropriate error messages are printed via `mock_print`, and that subsequent processing steps (like fuel optimization or logging) are not called.
*   **Helper Function Test Cases (e.g., `test_calc_time_earth_relativistic_zero_speed`, `test_calc_age_valid_inputs`, `test_calc_arrival_valid_inputs`, `test_convert_date_valid`)**:
    *   **Inputs**: Direct arguments to `main.calc_time_earth`, `main.calc_age`, `main.calc_arrival`, `main.convert_date`.
    *   **Outputs/Side Effects**: Assert the correctness of the return values for various valid and edge-case inputs, including checking for specific warnings printed and `ValueError` exceptions raised for invalid inputs.
*   **`test_main_function_average_speed_fallback` (Test Function)**:
    *   **Inputs**: Uses `mock_dependencies` and `mock_input`, specifically mocking a zero `average_hohmann_speed_ms`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that a warning is printed regarding the fallback speed, and that `mock_save_travel_log` is called with the expected fallback speed (0.1% of C).

### Dependencies

*   `pytest`: For the testing framework and fixtures.
*   `unittest.mock.patch`, `MagicMock`, `call`: For mocking external dependencies and internal functions.
*   `datetime.datetime`, `timedelta`: For date and time calculations and assertions.
*   `math`: For mathematical operations like `sqrt` in relativistic calculations.
*   `sys`: Imported but not directly used in the provided snippet.
*   `main`: The module under test.
*   `constants.C_LIGHT_MPS`: A specific constant used in relativistic calculations.

---


## `tests/test_trajectory_planner.py`

This file contains unit tests for the `TrajectoryPlanner` class, verifying its initialization and its `plan_trajectory` method, specifically focusing on Hohmann transfer calculations. It extensively uses mocking to isolate the `TrajectoryPlanner` logic from its external data and calculation dependencies.

### Key Components:

*   **`mock_celestial_data_for_planner` (pytest fixture)**:
    *   **Inputs**: Patches `trajectory_planner.celestial_data.get_celestial_body_data`.
    *   **Outputs/Side Effects**: Returns mocked static data for celestial bodies (Sun, Earth, Mars, Jupiter), including mass, radius, gravitational parameter, semi-major axis, and orbital period.
*   **`mock_orbital_mechanics` (pytest fixture)**:
    *   **Inputs**: Patches `trajectory_planner.orbital_mechanics.calculate_hohmann_transfer_delta_v` and `calculate_hohmann_transfer_time_of_flight`.
    *   **Outputs/Side Effects**: Mocks these functions to return fixed, predetermined values for delta-v and time-of-flight.
*   **`mock_ephemeris_get_body_orbital_state` (pytest fixture)**:
    *   **Inputs**: Patches `trajectory_planner.ephemeris.get_body_orbital_state`.
    *   **Outputs/Side Effects**: Mocks this function to return dynamic `distance_from_sun_m` for specific celestial bodies (Earth, Mars) based on a given date, simulating real-time ephemeris data.
*   **`test_trajectory_planner_init_...` functions**:
    *   **Inputs**: `mock_celestial_data_for_planner`.
    *   **Outputs/Side Effects**: Test `TrajectoryPlanner`'s constructor, verifying successful initialization with valid Sun data and raising appropriate errors for missing or invalid data.
*   **`test_plan_trajectory_hohmann_...` functions**:
    *   **Inputs**: Fixtures (`mock_celestial_data_for_planner`, `mock_orbital_mechanics`, `mock_ephemeris_get_body_orbital_state`) and specific parameters for `plan_trajectory` (e.g., departure/arrival bodies, date, trajectory type).
    *   **Outputs/Side Effects**: Validate the `plan_trajectory` method for Hohmann transfers under various scenarios, including:
        *   Successful planning using dynamic ephemeris data.
        *   Fallback to static celestial data when ephemeris is not used or fails.
        *   Error handling for invalid inputs (empty/same bodies, non-existent bodies).
        *   Error handling for failures in ephemeris data retrieval or orbital mechanics calculations.
        *   Correct formatting of travel time.
*   **`test_plan_trajectory_default_type_hohmann_with_date`**:
    *   **Inputs**: Fixtures.
    *   **Outputs/Side Effects**: Confirms that `plan_trajectory` defaults to "Hohmann Transfer" if no type is explicitly specified.
*   **`test_plan_trajectory_unsupported_type_with_date` / `test_plan_trajectory_invalid_type_non_string_with_date`**:
    *   **Inputs**: Fixtures.
    *   **Outputs/Side Effects**: Verify that `plan_trajectory` correctly handles unsupported or invalid trajectory types.

### Dependencies:

*   `pytest`: Testing framework.
*   `unittest.mock.patch`, `MagicMock`, `call`: For creating mocks and asserting calls.
*   `datetime.timedelta`, `datetime.datetime`: For handling dates and time durations.
*   `math`: Potentially used by the system under test, but not directly by test logic.
*   `trajectory_planner` (relative import): The class being tested.
*   `celestial_data` (relative import, mocked): Provides static celestial body information.
*   `orbital_mechanics` (relative import, mocked): Provides orbital calculation functions.
*   `constants` (relative import): General constants (not directly used in tests, likely by the SUT).
*   `ephemeris` (indirectly imported and patched via `trajectory_planner.ephemeris`): Provides dynamic orbital state data.

---


## `trajectory_planner.py`

```markdown
## TrajectoryPlanner.py Analysis

### 1. Purpose
This file defines a `TrajectoryPlanner` class designed to compute interplanetary trajectories between celestial bodies. It orchestrates calls to lower-level orbital mechanics and ephemeris modules to calculate details like total delta-v and travel time, considering dynamic orbital positions on a specified departure date.

### 2. Key Components

*   **`TrajectoryPlanner` Class**:
    *   **`__init__(self)`**:
        *   **Inputs**: None (retrieves Sun's gravitational parameter internally).
        *   **Outputs/Side Effects**: Initializes `self.mu_sun` (Sun's gravitational parameter). Raises `ValueError` or `AttributeError` if Sun data is missing or invalid.
    *   **`_plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime) -> dict`**:
        *   **Inputs**: Departure body name (string), arrival body name (string), departure date (datetime object).
        *   **Outputs**: A dictionary containing trajectory details (transfer type, delta-v, travel time in days and H:M:S, success status, error message) and dynamic distances from the Sun.
        *   **Side Effects**: Retrieves orbital states from `ephemeris` and calculates transfer parameters using `orbital_mechanics`.
    *   **`_plan_direct_transfer(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime) -> dict`**:
        *   **Inputs**: Departure body name (string), arrival body name (string), departure date (datetime object).
        *   **Outputs**: A dictionary indicating that this trajectory type is not yet implemented.
    *   **`plan_trajectory(self, departure_body_name: str, arrival_body_name: str, trajectory_type: str = 'Hohmann', **kwargs) -> dict`**:
        *   **Inputs**: Departure body name (string), arrival body name (string), trajectory type (string, default 'Hohmann'), and keyword arguments including `departure_date` (string in 'YYYY-MM-DD' format).
        *   **Outputs**: A dictionary with trajectory details or an error message, based on the selected `trajectory_type`.
        *   **Side Effects**: Acts as a dispatcher, validating inputs, parsing the departure date, and calling the appropriate internal planning method (`_plan_hohmann_trajectory` or `_plan_direct_transfer`).

*   **`if __name__ == '__main__':` block**:
    *   **Inputs**: Hardcoded test cases for various trajectory planning scenarios, including valid, invalid, and unimplemented types.
    *   **Outputs/Side Effects**: Prints the results of the planned trajectories or error messages to the console, demonstrating the class's functionality and error handling.

### 3. Dependencies
*   `math`
*   `datetime` (from `datetime` module)
*   `timedelta` (from `datetime` module)
*   `orbital_mechanics` (local module)
*   `celestial_data` (local module)
*   `ephemeris` (local module)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
