# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 18

**Last Updated:** 2025-11-18 21:38:07

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

This file centralizes astrophysical data by storing universal constants and a detailed dictionary of properties for various celestial bodies within our solar system. It provides a function to easily retrieve this data.

### Key Components:

*   **`GRAVITATIONAL_CONSTANT`**: A global float constant representing the universal gravitational constant.
    *   Inputs: None
    *   Outputs: N/A (a constant value)
*   **`SPEED_OF_LIGHT`**: A global float constant representing the speed of light in vacuum.
    *   Inputs: None
    *   Outputs: N/A (a constant value)
*   **`CELESTIAL_BODIES_DATA`**: A global dictionary storing astrophysical data (mass, radius, gravitational parameter, average orbital radius) for celestial bodies, keyed by their uppercase names.
    *   Inputs: None
    *   Outputs: N/A (a data structure)
*   **`get_celestial_body_data(body_name: str)`**: A function that retrieves the data for a specified celestial body.
    *   Inputs: `body_name` (string, case-insensitive).
    *   Outputs: A dictionary of the celestial body's data if found, otherwise `None`.

### Dependencies:

*   None

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

```markdown
## constants.py Summary

### 1. Purpose
This module defines universal physical constants and other scientific constants relevant to space travel calculations within the `space_travel_calculator` application. It serves as a single source of truth for critical values, ensuring consistency and maintainability.

### 2. Key Components
This file primarily consists of variable definitions (constants).

*   **Universal Physical Constants Section**:
    *   **`C_LIGHT_MPS`**:
        *   **Description**: Represents the speed of light in a vacuum.
        *   **Inputs**: None (a literal numeric value).
        *   **Outputs/Side Effects**: Provides the exact value `299_792_458.0` meters per second for use in relativistic calculations and speed validation.
    *   **`G_GRAVITATIONAL`**:
        *   **Description**: Represents the gravitational constant.
        *   **Inputs**: None (a literal numeric value).
        *   **Outputs/Side Effects**: Provides the CODATA 2018 recommended value `6.67430e-11` m^3 kg^-1 s^-2 for fundamental space mechanics and future orbital calculations.
*   **Commented-out Examples**:
    *   The file includes commented-out examples (`MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`, `MU_EARTH`) to illustrate other potentially useful constants that could be added.

### 3. Dependencies
This file has no external dependencies or imports. It solely defines literal constant values.
```

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

### fuel_optimizer.py

1.  **Purpose**
    This file calculates the optimal fuel mass required for a planned space trajectory by integrating delta-V requirements from a trajectory planner with propulsion system physics. It acts as an orchestrator between orbital mechanics and rocket equation calculations.

2.  **Key Components**
    *   `calculate_fuel_mass_from_delta_v` (Mock/Imported from `propulsion_system.py`)
        *   **Inputs**: `delta_v` (float), `spacecraft_dry_mass` (float), `specific_impulse` (float)
        *   **Output**: Calculated fuel mass in kilograms (float).
    *   `calculate_delta_v` (Mock/Imported from `trajectory_planner.py`)
        *   **Inputs**: `start_body` (str), `end_body` (str), `trajectory_type` (str), and optional `**kwargs` for trajectory specifics.
        *   **Output**: Required change in velocity (delta-V) in meters per second (float).
    *   `optimize_fuel_for_trajectory` (Main function)
        *   **Inputs**: `start_body` (str), `end_body` (str), `trajectory_type` (str), `spacecraft_dry_mass` (float), `engine_specific_impulse` (float), and optional `**trajectory_args`.
        *   **Output**: The calculated optimal fuel mass in kilograms (float).
        *   **Side Effects**: Raises `ValueError` for invalid inputs or invalid results from dependency functions, and `RuntimeError` for unexpected errors during the optimization process.

3.  **Dependencies**
    *   `math` (Python standard library)
    *   `sys` (Python standard library)
    *   `os` (Python standard library - imported but not explicitly used in the provided code)
    *   `propulsion_system` (Custom module, expected to contain `calculate_fuel_mass_from_delta_v`)
    *   `trajectory_planner` (Custom module, expected to contain `calculate_delta_v`)

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
This `main.py` file implements a space travel calculator that computes the time, fuel, and cost required for a user to reach a chosen celestial destination, incorporating relativistic effects and orbital mechanics.

### Key Components:

*   **`main()` function**:
    *   **Inputs**: Gathers user inputs for source/destination planets, spacecraft dry mass, engine specific impulse (ISP), departure date, and user age via console prompts.
    *   **Outputs/Side Effects**: Orchestrates the entire calculation flow, prints a comprehensive travel summary (Delta-V, fuel mass/cost, travel times in traveler's and Earth's frames, arrival age, estimated arrival date) to the console, and logs travel details using the `travel_logger` module.
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: `years_traveler_frame` (float), `average_speed_ms` (float).
    *   **Outputs**: Returns the travel time in Earth's reference frame (float), accounting for relativistic time dilation.
*   **`calc_age(years, age)`**:
    *   **Inputs**: `years` (float), `age` (int).
    *   **Outputs**: Returns the user's estimated age upon arrival (int).
*   **`calc_arrival(date, years_earth_frame)`**:
    *   **Inputs**: `date` (datetime.datetime), `years_earth_frame` (float).
    *   **Outputs**: Returns the estimated arrival date as a `datetime.datetime` object, or `None` if the calculation fails due to extreme durations.
*   **`convert_date(date_str)`**:
    *   **Inputs**: `date_str` (string in 'YYYY-MM-DD' format).
    *   **Outputs**: Returns a `datetime.datetime` object parsed from the input string.

### Dependencies:

*   `datetime` (standard library): For date and time manipulations (`datetime`, `timedelta`).
*   `math` (standard library): For mathematical operations, particularly `sqrt` and `floor`.
*   `checks` (local module, aliased as `c`): Provides utility functions for input validation (e.g., `is_valid_date`, `is_valid_age`).
*   `celestial_data` (local module): Supplies data for celestial bodies via `get_planet_data`.
*   `orbital_mechanics` (local module): Referenced as foundational but not directly called in `main`.
*   `trajectory_planner` (local module): Calculates orbital trajectories, specifically `calculate_hohmann_transfer`.
*   `propulsion_system` (local module): Calculates fuel requirements via `calculate_fuel_mass`.
*   `fuel_calc` (local module): Imported but not explicitly used for calculations in `main`; fuel cost is directly computed.
*   `travel_logger` (local module): Logs travel details using `save_travel_log`.
```

---


## `orbital_mechanics.py`

```markdown
## Analysis of `orbital_mechanics.py`

### Purpose
This file provides a collection of functions for performing fundamental calculations in orbital mechanics, enabling the computation of parameters such as gravitational properties, orbital velocities, transfer maneuvers, and escape velocities for celestial bodies.

### Key Components
*   **`calculate_gravitational_parameter(central_body_name: str)`**:
    *   **Inputs**: The name of a central celestial body.
    *   **Outputs**: The standard gravitational parameter (mu) for that body.
*   **`calculate_circular_orbital_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter and an orbital radius.
    *   **Outputs**: The velocity required for a stable circular orbit.
*   **`calculate_hohmann_transfer_delta_v(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter, and the radii of initial and final circular orbits.
    *   **Outputs**: A tuple containing the Delta-V for the first burn, the second burn, and the total absolute Delta-V for a Hohmann transfer.
*   **`calculate_hohmann_transfer_time_of_flight(mu: float, r1: float, r2: float)`**:
    *   **Inputs**: A central body's gravitational parameter, and the radii of initial and final circular orbits.
    *   **Outputs**: The time taken for a Hohmann transfer.
*   **`calculate_elliptical_orbital_period(mu: float, semi_major_axis: float)`**:
    *   **Inputs**: A central body's gravitational parameter and the semi-major axis of an orbit.
    *   **Outputs**: The orbital period using Kepler's Third Law.
*   **`calculate_escape_velocity(mu: float, radius: float)`**:
    *   **Inputs**: A central body's gravitational parameter and a distance from its center.
    *   **Outputs**: The escape velocity from that point.

### Dependencies
*   **`math`**: Used for mathematical operations like square roots (`math.sqrt`) and pi (`math.pi`).
*   **`constants`**: Expected to provide physical constants, specifically `constants.GRAVITATIONAL_CONSTANT`.
*   **`celestial_bodies`**: Expected to provide data on celestial bodies, specifically `celestial_bodies.get_body_mass()` to retrieve body masses.
```

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `trajectory_planner.py`

```markdown
## Trajectory Planner Analysis

### Purpose
This file provides a high-level interface for planning interplanetary Hohmann transfer trajectories between celestial bodies orbiting the Sun. It orchestrates calculations to determine parameters like total delta-v and travel time.

### Key Components
*   **Mock Imports Section**: Provides mock implementations for `orbital_mechanics`, `celestial_bodies`, and `constants` modules if they are not found, allowing standalone execution and testing.
    *   `MockOrbitalMechanics.calculate_hohmann_transfer(mu_central: float, r1: float, r2: float)`:
        *   **Inputs**: Standard gravitational parameter of the central body (`mu_central`), initial orbit radius (`r1`), final orbit radius (`r2`).
        *   **Outputs**: A tuple `(total_delta_v_mps, travel_time_s)`.
    *   `MockCelestialBodies.get_celestial_body_data(body_name: str)`:
        *   **Inputs**: Name of the celestial body.
        *   **Outputs**: A dictionary of body data or `None`.
    *   `MockConstants`: Provides `GRAVITATIONAL_CONSTANT` and `SUN_STANDARD_GRAVITATIONAL_PARAMETER`.
*   **`TrajectoryPlanner` Class**: The main class for planning trajectories.
    *   `__init__(self)`:
        *   **Inputs**: None.
        *   **Outputs/Side Effects**: Initializes `self.mu_sun` with the Sun's standard gravitational parameter.
    *   `plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str)`:
        *   **Inputs**: Names of the departure and arrival celestial bodies (strings).
        *   **Outputs**: A dictionary containing trajectory details, including departure/arrival bodies, transfer type, `total_delta_v_mps`, `travel_time_days`, `travel_time_h_m_s`, `success` status, and an `error` message if applicable.
*   **`if __name__ == '__main__':` Block**:
    *   **Inputs**: None (uses hardcoded body names for examples).
    *   **Outputs/Side Effects**: Demonstrates the usage of `TrajectoryPlanner` by printing planning results and error messages to the console for various scenarios.

### Dependencies
*   `math` (standard library)
*   `datetime.timedelta` (standard library)
*   `orbital_mechanics` (external, mocked internally if not found)
*   `celestial_bodies` (external, mocked internally if not found)
*   `constants` (external, mocked internally if not found)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
