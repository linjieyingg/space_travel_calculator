# Code Repository Summary

*Auto-generated by Gemini AI*


**Repository:** linjieyingg/space_travel_calculator

**Branch:** main

**Files Analyzed:** 23

**Last Updated:** 2025-11-18 23:10:05

---


## `celestial_bodies.py`

```markdown
### Purpose
This module stores structured data for solar system celestial bodies, including their physical properties, gravitational parameters, and orbital characteristics. It serves as a data source for orbital mechanics calculations and simplified space travel planning.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: A float constant representing the universal gravitational constant in m^3 kg^-1 s^-2, provided for reference.
*   **`SOLAR_SYSTEM_BODIES_DATA`**: A dictionary containing comprehensive data for various celestial bodies (Sun, planets, Moon). Each entry is a dictionary with keys for 'mass', 'radius', 'gravitational_parameter_mu', 'semi_major_axis_from_sun', and 'average_distance_from_earth'.
*   **`get_celestial_body_data(name: str)` function**:
    *   **Inputs**: `name` (str), the case-insensitive name of a celestial body.
    *   **Outputs**: A `dict` containing the body's data if found, or `None` if the body is not found or the input is not a string.
*   **`get_all_solar_system_destinations()` function**:
    *   **Inputs**: None.
    *   **Outputs**: A `list` of dictionaries, where each dictionary represents a destination with its 'name' (str) and 'distance' (float, average distance from Earth). Earth is excluded, and the list is sorted by distance.
*   **`if __name__ == "__main__":` block**: Contains self-testing code that demonstrates the usage of `get_celestial_body_data` and `get_all_solar_system_destinations` functions, including handling valid, invalid, and non-existent inputs.

### Dependencies
None. This file is self-contained and does not use any external imports.
```

---


## `celestial_data.py`

```markdown
## Analysis of `celestial_data.py`

### Purpose
This module serves as the definitive source for astrophysical data within the `space_travel_calculator` application, centralizing detailed parameters for solar system celestial bodies. It provides functions to retrieve this data and list potential destinations, while also re-exporting universal physical constants for consistency.

### Key Components
*   **`GRAVITATIONAL_CONSTANT`**: Global constant re-exported from `constants`, representing the Gravitational Constant (m³ kg⁻¹ s⁻²).
*   **`SPEED_OF_LIGHT`**: Global constant re-exported from `constants`, representing the Speed of Light (m/s).
*   **`CELESTIAL_BODIES_DATA`**: A dictionary containing detailed astrophysical data for various celestial bodies (e.g., mass, radius, gravitational parameter, semi-major axis from Sun, orbital period).
*   **`get_celestial_body_data(body_name: str)`**:
    *   **Inputs**: `body_name` (string, case-insensitive name of a celestial body).
    *   **Outputs**: A dictionary containing the body's data if found, otherwise `None`.
*   **`get_all_solar_system_destinations()`**:
    *   **Inputs**: None.
    *   **Outputs**: A list of dictionaries, each with 'name' and calculated 'distance' from Earth (in meters), sorted by distance. Returns `None` if Earth's data is missing.

### Dependencies
*   **`math`**: Used for `math.fabs()` in distance calculations.
*   **`constants`**: Imports `G_GRAVITATIONAL` (as `GRAVITATIONAL_CONSTANT`) and `C_LIGHT_MPS` (as `SPEED_OF_LIGHT`).
```

---


## `checks.py`

This Python file provides validation functions for various inputs related to a hypothetical space travel calculator.

### Purpose
This file contains utility functions to validate user-provided data such as dates, travel speeds, and ages, ensuring they meet specific criteria for a space travel calculation application.

### Key Components
*   **`is_valid_date(date_str, format_str='%Y-%m-%d')`**
    *   **Inputs**: `date_str` (string representing a date), `format_str` (optional string specifying the expected date format, default is `'%Y-%m-%d'`).
    *   **Outputs**: Returns `True` if `date_str` can be successfully parsed into a date using `format_str`, `False` otherwise.
*   **`is_valid_speed(speed)`**
    *   **Inputs**: `speed` (numeric value, implicitly in km/s based on internal conversion).
    *   **Outputs**: Returns `True` if the `speed` is positive and does not exceed the speed of light (299,792,458 m/s), `False` otherwise.
*   **`is_valid_age(age)`**
    *   **Inputs**: `age` (numeric value).
    *   **Outputs**: Returns `True` if the `age` is between 18 (inclusive) and 75 (exclusive), `False` otherwise.

### Dependencies
*   `datetime` from the standard `datetime` module.

---


## `constants.py`

This module, `constants.py`, serves as a central repository for universal physical and scientific constants relevant to space travel calculations within the `space_travel_calculator` application, ensuring consistency and maintainability.

### Key Components:

*   **Universal Physical Constants Section**:
    *   `C_LIGHT_MPS`: Defines the speed of light in a vacuum (299,792,458.0 m/s). It takes no input but provides a constant value for relativistic calculations and speed validation.
    *   `G_GRAVITATIONAL`: Defines the Gravitational Constant (6.67430e-11 m³ kg⁻¹ s⁻²). It takes no input but provides a fundamental constant for space mechanics and future orbital calculations.
    *   `GRAVITATIONAL_CONSTANT`: An alias for `G_GRAVITATIONAL`. It takes `G_GRAVITATIONAL` as its value and provides backward compatibility for modules expecting this specific name.
*   **Commented-out Examples**: Includes examples of other potential constants (e.g., `MU_SUN`, `AU_TO_METERS`, `EARTH_RADIUS_METERS`) that can be added for future expansion.

### Dependencies:

*   None. This file does not import any external modules or libraries.

---


## `ephemeris.py`

This Python file, `ephemeris.py`, calculates the approximate heliocentric (Sun-centered) orbital state (distance and angular position) for celestial bodies using a simplified circular orbit model based on Kepler's laws. It provides a foundational mechanism for basic astronomical position estimations for planets.

### Key Components:

*   **`J2000_EPOCH`**: A `datetime.datetime` constant representing the J2000.0 epoch in UTC, used as a reference for time difference calculations.
*   **`_get_mu_sun()`**:
    *   **Inputs**: None.
    *   **Outputs**: Returns the Sun's gravitational parameter (mu) as a float (m^3/s^2), internally caching the result for efficiency. Raises `ValueError` if the parameter cannot be retrieved or is invalid.
*   **`get_heliocentric_state(body_name: str, date: datetime.datetime)`**:
    *   **Inputs**:
        *   `body_name` (str): The case-insensitive name of a celestial body (e.g., 'Mars').
        *   `date` (datetime.datetime): The specific date and time (timezone-aware recommended, naive dates are converted to UTC).
    *   **Outputs**: A dictionary containing:
        *   `"distance_from_sun_m"` (float): Approximate distance from the Sun in meters.
        *   `"angular_position_rad"` (float): Approximate angular position in radians (0 to 2*pi).
    *   **Side Effects**: Raises `ValueError` for invalid inputs, missing celestial data, or if the calculation is requested for the Sun or Moon (which are explicitly not supported by this simplified model).
*   **`if __name__ == '__main__':`**:
    *   **Purpose**: Contains a comprehensive self-test suite demonstrating the `get_heliocentric_state` function with valid inputs, invalid inputs, edge cases (past dates, naive datetimes), and unsupported bodies, printing results and caught errors.

### Dependencies:

*   `math`
*   `datetime`
*   `celestial_data` (specifically `get_celestial_body_data`)
*   `orbital_mechanics` (specifically `calculate_gravitational_parameter`, `calculate_elliptical_orbital_period`)

---


## `fuel_calc.py`

```markdown
## File: fuel_calc.py

### Purpose
This file provides a utility function to calculate the total cost of fuel based on the required fuel mass and its price per unit mass, including input validation.

### Key Components

*   **Function: `calculate_fuel_cost`**
    *   **Inputs**:
        *   `total_fuel_mass_needed` (numeric): The total mass of fuel required (e.g., in kg).
        *   `fuel_price_per_unit` (numeric): The cost of one unit of fuel mass (e.g., cost per kg).
    *   **Outputs**:
        *   Returns a dictionary containing `'total_fuel_mass_needed'` and `'total_cost'` if inputs are valid (numeric and non-negative).
        *   Returns `None` if `total_fuel_mass_needed` or `fuel_price_per_unit` is negative or not a valid numeric type (int or float).

### Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `fuel_optimizer.py`

```markdown
## fuel_optimizer.py

### 1. Purpose
This file orchestrates the calculation of optimal fuel mass required for a spacecraft's trajectory. It integrates a trajectory planner to determine the necessary delta-V and then uses a propulsion system model to compute the fuel mass based on that delta-V and engine parameters.

### 2. Key Components
*   **`optimize_fuel_for_trajectory` function**:
    *   **Inputs**:
        *   `start_body` (str): Origin celestial body.
        *   `end_body` (str): Target celestial body.
        *   `trajectory_type` (str): The type of trajectory (currently only 'Hohmann' supported).
        *   `spacecraft_dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `engine_specific_impulse` (float): Engine's specific impulse (seconds).
        *   `**trajectory_args`: Additional keyword arguments passed to the trajectory planner (e.g., `launch_date`).
    *   **Outputs**:
        *   `float`: The calculated optimal fuel mass in kilograms.
    *   **Side Effects**:
        *   Raises `ValueError` for invalid inputs or calculation issues.
        *   Raises `RuntimeError` for unexpected errors during planning or calculation.
        *   Raises `ImportError` if critical dependencies are missing.
*   **Internal Logic**:
    *   Instantiates `TrajectoryPlanner`.
    *   Calls `planner.plan_trajectory` to get `total_delta_v`.
    *   Calls `calculate_fuel_mass_from_delta_v` (from `propulsion_system`) to compute fuel mass.

### 3. Dependencies
*   **`math`**: Standard Python mathematical functions (imported, though not explicitly used within this file's direct logic).
*   **`propulsion_system`**: Imports `calculate_required_fuel_mass` (aliased as `calculate_fuel_mass_from_delta_v`).
*   **`trajectory_planner`**: Imports the `TrajectoryPlanner` class.
```

---


## `generated/2048_game.py`

This file implements the classic 2048 puzzle game, allowing a player to interact with it via console input. It manages the game board, score, tile generation, movement logic, and win/game over conditions.

### Key Components:

*   **Class `Game2048`**: Represents the game state and logic.
    *   `__init__()`: Initializes a 4x4 grid, sets score to 0, adds two initial random tiles, and sets game state flags (`won`, `game_over`).
    *   `add_random_tile()`: Finds an empty cell and places either a 2 (90% chance) or a 4 (10% chance). Returns `True` if a tile was added, `False` otherwise.
    *   `display_board()`: Clears the console and prints the current score and the game grid in a formatted way.
    *   `_get_row_view(r)`: Inputs row index `r`, outputs the specified row (list).
    *   `_set_row_view(r, new_row)`: Inputs row index `r` and a `new_row` list, updates the specified row in the grid.
    *   `_get_col_view(c)`: Inputs column index `c`, outputs the specified column (list).
    *   `_set_col_view(c, new_col)`: Inputs column index `c` and a `new_col` list, updates the specified column in the grid.
    *   `_shift_and_merge(line)`: Inputs a list representing a row or column, outputs the shifted and merged line (list) and a boolean indicating if any change occurred. It handles shifting non-zero tiles and merging identical adjacent tiles, updating the game score and checking for a win (2048 tile).
    *   `move(direction)`: Inputs a string ('up', 'down', 'left', 'right'), applies `_shift_and_merge` to the relevant rows/columns (handling reversals for 'down' and 'right'), adds a new random tile if a valid move occurred, and checks for game over. Returns `True` if a move happened, `False` otherwise.
    *   `check_game_over()`: Checks if there are any empty cells or possible merges in rows/columns. Sets `self.game_over` to `True` if no more moves are possible, otherwise `False`.
*   **Function `play_2048()`**:
    *   Inputs: None.
    *   Outputs/Side Effects: Runs the main game loop, displaying the board, prompting for user input (W/A/S/D for moves or 'q' to quit), and printing final game status (win/game over, score).

### Dependencies:

*   `random`: Used for generating random tile values and positions.
*   `os`: Used for clearing the console for a cleaner display.

---


## `generated/change_four_to_five_in_a_row.py`

```markdown
1.  **Purpose**: This file defines a utility function to update text by replacing all instances of the phrase "four in a row" with "five in a row," primarily for updating game titles or descriptions.
2.  **Key Components**:
    *   **`update_game_reference(text: str) -> str`**:
        *   **Inputs**: Takes a single string argument named `text`.
        *   **Outputs**: Returns a new string where all occurrences of "four in a row" have been replaced by "five in a row".
3.  **Dependencies**: None. This file does not import any external modules or libraries.
```

---


## `generated/count_vowels.py`

```markdown
## File Analysis: `generated/count_vowels.py`

### 1. Purpose
This Python script defines a function to count the occurrences of vowels (a, e, i, o, u), case-insensitively, within a given input string.

### 2. Key Components
*   **Function**: `count_vowels`
    *   **Inputs**: `text` (str) - The string to be analyzed.
    *   **Outputs**: An integer representing the total count of vowels found in the string.

### 3. Dependencies
None. This file does not rely on any external imports or libraries.
```

---


## `generated/four_in_a_row.py`

This Python file implements a command-line based Four-in-a-Row (Connect Four) game for two players. It handles game setup, player turns, piece dropping, win condition checking, and board display.

### Key Components:

*   **`create_board()`**:
    *   **Inputs**: None
    *   **Outputs**: Returns a 2D list representing an empty game board (6 rows, 7 columns), with `0` for empty slots.
*   **`print_board(board)`**:
    *   **Inputs**: `board` (2D list, the current game board).
    *   **Outputs/Side Effects**: Prints the board state to the console, using 'X' for Player 1 and 'O' for Player 2, and displays column numbers.
*   **`is_valid_location(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns `True` if the column is within bounds and not full, `False` otherwise.
*   **`get_next_open_row(board, col)`**:
    *   **Inputs**: `board` (2D list), `col` (integer, 0-indexed column).
    *   **Outputs**: Returns the 0-indexed row number of the lowest available slot in the specified column.
*   **`drop_piece(board, row, col, piece)`**:
    *   **Inputs**: `board` (2D list), `row` (integer), `col` (integer), `piece` (integer, 1 or 2).
    *   **Outputs/Side Effects**: Modifies the `board` by placing `piece` at the given `row` and `col`.
*   **`winning_move(board, piece)`**:
    *   **Inputs**: `board` (2D list), `piece` (integer, 1 or 2).
    *   **Outputs**: Returns `True` if the `piece` has formed four consecutive pieces (horizontally, vertically, or diagonally), `False` otherwise.
*   **`is_board_full(board)`**:
    *   **Inputs**: `board` (2D list).
    *   **Outputs**: Returns `True` if all slots on the board are filled, `False` otherwise.
*   **`four_in_a_row_game()`**:
    *   **Inputs**: None
    *   **Outputs/Side Effects**: Orchestrates the entire game loop, handling player input, board updates, game state checks, and printing game messages to the console.

### Dependencies:

*   `sys`: Used for `sys.stdout.flush()` to ensure immediate console output.

---


## `generated/spacecraft_id_validation.py`

```markdown
## File Analysis: `generated/spacecraft_id_validation.py`

**1. Purpose**
This file defines a utility function to validate spacecraft IDs against a set of predefined criteria, ensuring they meet specific formatting and length requirements.

**2. Key Components**
*   **`validate_spacecraft_id(spacecraft_id: str) -> bool`**
    *   **Inputs**: `spacecraft_id` (str) - The ID string to be validated.
    *   **Outputs**: `bool` - Returns `True` if the `spacecraft_id` is valid according to the rules (string, non-empty, alphanumeric, 5-20 characters long), otherwise returns `False`.

**3. Dependencies**
*   `re`: Python's built-in regular expression module, used for checking if the ID is alphanumeric.
```

---


## `generated/tictactoe.py`

```markdown
### File Analysis: `generated/tictactoe.py`

**1. Purpose**
This Python script implements a command-line Tic-Tac-Toe game for two players. It manages game setup, player turns, board display, and determines win or draw conditions.

**2. Key Components**
*   **`play_tic_tac_toe()`**:
    *   **Inputs**: None (interacts with user via `input()`).
    *   **Outputs/Side Effects**: Manages the entire game flow, prints game messages, the board, and final results to the console.
*   **`display_board(current_board)`**:
    *   **Inputs**: `current_board` (a list of 9 strings representing the board state).
    *   **Outputs/Side Effects**: Prints the current Tic-Tac-Toe board to the console in a formatted 3x3 grid.
*   **`check_win(current_board, player)`**:
    *   **Inputs**: `current_board` (list of 9 strings), `player` (string, 'X' or 'O').
    *   **Outputs/Side Effects**: Returns `True` if the given `player` has achieved three marks in a row (horizontal, vertical, or diagonal), `False` otherwise. No side effects.
*   **`check_draw(current_board)`**:
    *   **Inputs**: `current_board` (list of 9 strings).
    *   **Outputs/Side Effects**: Returns `True` if all spaces on the board are filled and no player has won (indicating a draw), `False` otherwise. No side effects.

**3. Dependencies**
*   `random`: Used to randomly select which player (X or O) starts the game.
```

---


## `main.py`

```markdown
## Purpose
This file implements a space travel calculator that determines the time, fuel requirements, and cost for a user to reach a chosen celestial destination, factoring in relativistic effects and orbital mechanics.

## Key Components
*   **`calc_time_earth(years_traveler_frame, average_speed_ms)`**:
    *   **Inputs**: Travel time in the traveler's frame (years), average spacecraft speed (m/s).
    *   **Outputs**: Travel time in Earth's reference frame (years).
    *   **Side Effects**: Prints warnings for invalid speeds or calculation errors.
*   **`calc_age(years_travel_time, starting_age)`**:
    *   **Inputs**: Total travel time (years), user's starting age (int).
    *   **Outputs**: User's age upon arrival (float).
    *   **Side Effects**: Raises `ValueError` for non-positive or non-numeric inputs.
*   **`calc_arrival(departure_date, years_earth_frame)`**:
    *   **Inputs**: Departure date (`datetime`), travel time in Earth's frame (years).
    *   **Outputs**: Estimated arrival date (`datetime`) or `None` if calculation fails.
    *   **Side Effects**: Prints warnings/errors for date calculation issues.
*   **`convert_date(date_str)`**:
    *   **Inputs**: Date string in 'YYYY-MM-DD' format.
    *   **Outputs**: Converted `datetime` object.
*   **`main()`**:
    *   **Inputs**: None (gathers user input interactively from the console).
    *   **Outputs**: Prints a comprehensive travel summary to the console.
    *   **Side Effects**:
        *   Initializes `TrajectoryPlanner`.
        *   Retrieves celestial body data using `celestial_data`.
        *   Plans trajectory using `TrajectoryPlanner`.
        *   Optimizes fuel and calculates mass needed using `fuel_optimizer`.
        *   Calculates fuel cost using `fuel_calc`.
        *   Performs time dilation (`calc_time_earth`), age (`calc_age`), and arrival date (`calc_arrival`) calculations.
        *   Logs travel details using `travel_logger`.

## Dependencies
*   `math` (for mathematical operations like `sqrt`)
*   `datetime`, `timedelta` (for date and time manipulations)
*   `checks` (imported as `c`, likely for input validation)
*   `celestial_data` (for retrieving information about celestial bodies)
*   `orbital_mechanics` (imported but not directly called in `main`)
*   `trajectory_planner.TrajectoryPlanner` (for planning the spacecraft's path)
*   `propulsion_system` (imported but not directly called in `main`)
*   `fuel_calc` (for calculating fuel cost)
*   `travel_logger` (for saving travel details)
*   `constants.C_LIGHT_MPS` (for the speed of light constant)
*   `fuel_optimizer` (for calculating optimized fuel mass)
```

---


## `orbital_mechanics.py`

```markdown
## File: orbital_mechanics.py

### 1. Purpose
This file provides a collection of functions for performing fundamental calculations in 3D orbital mechanics. It includes utility functions for vector operations, standard formulas for circular and elliptical orbits, Hohmann transfers, escape velocity, and a simplified approximation for Lambertian transfers.

### 2. Key Components

*   **3D Vector Utility Functions (`_validate_vector`, `vector_magnitude`, `vector_subtract`, `vector_add`, `vector_scale`, `vector_dot`, `vector_cross`)**:
    *   **Inputs**: Two 3-element tuples (vectors) or a vector and a scalar.
    *   **Outputs**: A float (magnitude, dot product) or a 3-element tuple (resultant vector). Raises `ValueError` for invalid vector formats.
*   **`calculate_gravitational_parameter`**:
    *   **Inputs**: `central_body_name` (str).
    *   **Outputs**: The gravitational parameter (mu, float) for the specified body. Raises `ValueError` if data is missing or invalid.
*   **`calculate_circular_orbital_velocity`**:
    *   **Inputs**: `mu` (float), `radius` (float).
    *   **Outputs**: Circular orbital velocity (float) in m/s. Raises `ValueError` for non-positive inputs.
*   **`calculate_hohmann_transfer_delta_v`**:
    *   **Inputs**: `mu` (float), `r1` (float), `r2` (float).
    *   **Outputs**: A tuple containing `delta_v1`, `delta_v2`, and `total_delta_v` (all floats) for the Hohmann transfer. Raises `ValueError` for non-positive or equal radii.
*   **`calculate_hohmann_transfer_time_of_flight`**:
    *   **Inputs**: `mu` (float), `r1` (float), `r2` (float).
    *   **Outputs**: Time of flight (float) in seconds for a Hohmann transfer. Raises `ValueError` for non-positive or equal radii.
*   **`calculate_elliptical_orbital_period`**:
    *   **Inputs**: `mu` (float), `semi_major_axis` (float).
    *   **Outputs**: Orbital period (float) in seconds. Raises `ValueError` for non-positive inputs.
*   **`calculate_escape_velocity`**:
    *   **Inputs**: `mu` (float), `radius` (float).
    *   **Outputs**: Escape velocity (float) in m/s. Raises `ValueError` for non-positive inputs.
*   **`_get_body_orbital_velocity_vector`**:
    *   **Inputs**: `body_name` (str), `date` (datetime), `central_body_mu` (float).
    *   **Outputs**: An approximate 3-element tuple representing the body's velocity vector. It attempts to use an `ephemeris` module but falls back or raises `NotImplementedError` if sufficient data is unavailable or the module is not found.
*   **`calculate_lambert_transfer`**:
    *   **Inputs**: `mu` (float), `r1_vec` (tuple), `r2_vec` (tuple), `delta_t` (float).
    *   **Outputs**: A tuple containing `delta_v1_mag`, `delta_v2_mag`, `total_delta_v` (all floats for burn magnitudes), and the `calculated_time_of_flight`.
    *   **Note**: This function implements a **simplified analytical approximation** of Lambert's problem, making strong assumptions (e.g., `delta_t` as half a transfer orbit period) and is not a full iterative Lambert solver. Raises `ValueError` for invalid inputs or if the transfer is impossible under its simplifications.

### 3. Dependencies
*   `math` (standard library)
*   `datetime`, `timedelta` (standard library)
*   `constants.G_GRAVITATIONAL` (from `constants` module)
*   `celestial_data.get_celestial_body_data` (from `celestial_data` module)
*   `ephemeris.get_heliocentric_state` (conditionally imported within `_get_body_orbital_velocity_vector`, not a strict top-level dependency if the function's fallback is sufficient).
```

---


## `propulsion_system.py`

This file defines a utility for calculating the required fuel mass for a spacecraft to achieve a specific change in velocity using the Tsiolkovsky rocket equation. It provides a function that takes spacecraft and engine parameters to determine the necessary fuel.

### Key Components:

*   **`STANDARD_GRAVITY` (Constant)**:
    *   **Description**: A constant representing the standard acceleration due to gravity (9.80665 m/s^2), used in conversions related to specific impulse.
*   **`calculate_required_fuel_mass` (Function)**:
    *   **Inputs**:
        *   `delta_v` (float): Required change in velocity (m/s).
        *   `dry_mass` (float): Mass of the spacecraft without fuel (kg).
        *   `specific_impulse` (float, optional): Engine's specific impulse (s).
        *   `exhaust_velocity` (float, optional): Effective exhaust velocity of the engine (m/s).
    *   **Outputs**: Returns the required fuel mass (float) in kilograms.
    *   **Side Effects**: Raises `ValueError` for invalid input parameters (e.g., negative `delta_v`, non-positive `dry_mass`, missing engine characteristics, or invalid specific impulse/exhaust velocity).

### Dependencies:

*   **`math`**: Used for mathematical operations, specifically `math.exp` for exponential calculations in the rocket equation.

---


## `spacecraft_validator.py`

```markdown
## spacecraft_validator.py

1.  **Purpose**: This file defines a utility function responsible for validating spacecraft names against specific length and character type criteria.

2.  **Key Components**:
    *   **Function**: `validate_spacecraft_name`
        *   **Inputs**: `name` (str) - The spacecraft name string to be validated.
        *   **Outputs**: `bool` - Returns `True` if the name is between 3 and 20 characters long (inclusive) and consists only of alphanumeric characters, otherwise returns `False`. It also returns `False` if the input is not a string.

3.  **Dependencies**: None.
```

---


## `tests/test_celestial_data.py`

This file contains unit tests for functions that retrieve and process celestial body data. It ensures the `celestial_data` module's functions work correctly with valid, invalid, and non-existent inputs, and that destination lists are properly formatted and sorted.

### Key Components:

*   **`test_get_celestial_body_data_valid_input`**
    *   **Input:** A valid celestial body name (e.g., `'earth'`).
    *   **Output:** Asserts that a non-null dictionary is returned, containing expected keys like `mass` and `gravitational_parameter_mu`.
*   **`test_get_celestial_body_data_invalid_input`**
    *   **Input:** Invalid input types (e.g., `123`, `None`).
    *   **Output:** Asserts that `None` is returned for invalid inputs.
*   **`test_get_celestial_body_data_non_existent`**
    *   **Input:** A non-existent celestial body name (e.g., `'plutonot'`).
    *   **Output:** Asserts that `None` is returned.
*   **`test_get_all_solar_system_destinations`**
    *   **Input:** None.
    *   **Output:** Asserts that a non-empty list of dictionaries is returned, with each dictionary having 'name' and 'distance' keys, sorted by distance, and that 'Earth' is excluded.

### Dependencies:

*   `pytest` (testing framework)
*   `celestial_data` (module containing `get_celestial_body_data`, `get_all_solar_system_destinations`, and `CELESTIAL_BODIES_DATA` which are being tested)

---


## `tests/test_fuel_optimizer.py`

This file contains unit tests for the `optimize_fuel_for_trajectory` function within the `fuel_optimizer` module, using `pytest` for testing and `unittest.mock` for dependency mocking.

### Purpose
The purpose of this file is to thoroughly test the `optimize_fuel_for_trajectory` function, verifying its correct behavior under various conditions, including successful execution, invalid inputs, and error propagation from its dependencies (`TrajectoryPlanner` and a fuel calculation function from `propulsion_system`).

### Key Components

*   **`mock_dependencies_for_fuel_optimizer` (pytest fixture)**
    *   **Inputs**: None (a pytest fixture).
    *   **Outputs**: A dictionary containing mocked instances of `TrajectoryPlanner` and the `calculate_fuel_mass_from_delta_v` function (aliased in `fuel_optimizer`), pre-configured with default successful return values.
    *   **Side Effects**: Patches `fuel_optimizer.TrajectoryPlanner` and `fuel_optimizer.calculate_fuel_mass_from_delta_v` using `unittest.mock.patch`.
*   **`test_optimize_fuel_for_trajectory_success`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that `optimize_fuel_for_trajectory` returns the expected fuel mass and that its internal dependencies (`TrajectoryPlanner.plan_trajectory` and the fuel mass calculation) were called exactly once with the correct arguments.
*   **`test_optimize_fuel_for_trajectory_unsupported_trajectory_type`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised when an unsupported trajectory type is provided, and that no mocked dependencies were called.
*   **`test_optimize_fuel_for_trajectory_invalid_inputs` (parameterized)**
    *   **Inputs**: `dry_mass`, `specific_impulse`, `expected_error` (from `pytest.mark.parametrize`).
    *   **Outputs**: Asserts that a `ValueError` is raised for various invalid inputs (e.g., non-positive dry mass or specific impulse, non-numeric values).
*   **`test_optimize_fuel_for_trajectory_planner_returns_unsuccessful`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a failure status.
*   **`test_optimize_fuel_for_trajectory_planner_returns_invalid_delta_v`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if `TrajectoryPlanner.plan_trajectory` returns a negative `total_delta_v`.
*   **`test_optimize_fuel_for_trajectory_propulsion_system_raises_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (wrapped) is raised if the mocked fuel calculation function itself raises an error.
*   **`test_optimize_fuel_for_trajectory_propulsion_returns_negative_fuel`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` is raised if the mocked fuel calculation function returns a negative fuel mass.
*   **`test_optimize_fuel_for_trajectory_planner_raises_runtime_error`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `RuntimeError` (wrapped) is raised if `TrajectoryPlanner.plan_trajectory` raises an unexpected `RuntimeError`.
*   **`test_optimize_fuel_for_trajectory_planner_raises_type_error_with_kwargs`**
    *   **Inputs**: `mock_dependencies_for_fuel_optimizer` fixture.
    *   **Outputs**: Asserts that a `ValueError` (indicating a signature mismatch) is raised if `TrajectoryPlanner.plan_trajectory` raises a `TypeError`, such as from receiving unexpected keyword arguments.

### Dependencies

*   `pytest`: Test framework.
*   `unittest.mock.MagicMock`: For creating mock objects.
*   `unittest.mock.patch`: For temporarily replacing objects with mocks.
*   `fuel_optimizer`: The module under test, specifically importing `optimize_fuel_for_trajectory` and `TrajectoryPlanner`.

---


## `tests/test_main.py`

This file, `tests/test_main.py`, is a comprehensive Pytest suite designed to test the `main.py` application. Its primary purpose is to verify the correct integration of various modules within `main.py` and ensure robust error handling under different failure scenarios, as well as to test specific helper functions.

### Key Components

*   **`mock_dependencies` (Pytest Fixture)**:
    *   **Inputs**: None directly, but it patches numerous functions and classes from `main.py`'s dependencies (`celestial_data`, `trajectory_planner`, `fuel_optimizer`, `fuel_calc`, `travel_logger`, `builtins.input`, `builtins.print`, `main.c`).
    *   **Outputs/Side Effects**: Yields a dictionary of configured mock objects, allowing test functions to interact with and assert calls on these mocks. It sets up `side_effect` and `return_value` for various mocked functions to simulate different system behaviors.
*   **`test_main_function_integrates_all_components_correctly` (Test Function)**:
    *   **Inputs**: Uses the `mock_dependencies` fixture and simulates user input via `mock_input`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that all mocked external functions are called with expected arguments, and that `main.main()` produces the correct output messages via `mock_print` and logs travel details via `mock_save_travel_log`. It specifically checks relativistic time calculations, estimated arrival dates, and age calculations.
*   **Error Handling Test Functions (e.g., `test_main_function_trajectory_planner_fails`, `test_main_function_fuel_optimizer_raises_value_error`)**:
    *   **Inputs**: Use `mock_dependencies` and `mock_input`, but configure specific mocks to simulate failures (e.g., `return_value={'success': False}` or `side_effect=ValueError`).
    *   **Outputs/Side Effects**: Call `main.main()` and assert that appropriate error messages are printed via `mock_print`, and that subsequent processing steps (like fuel optimization or logging) are not called.
*   **Helper Function Test Cases (e.g., `test_calc_time_earth_relativistic_zero_speed`, `test_calc_age_valid_inputs`, `test_calc_arrival_valid_inputs`, `test_convert_date_valid`)**:
    *   **Inputs**: Direct arguments to `main.calc_time_earth`, `main.calc_age`, `main.calc_arrival`, `main.convert_date`.
    *   **Outputs/Side Effects**: Assert the correctness of the return values for various valid and edge-case inputs, including checking for specific warnings printed and `ValueError` exceptions raised for invalid inputs.
*   **`test_main_function_average_speed_fallback` (Test Function)**:
    *   **Inputs**: Uses `mock_dependencies` and `mock_input`, specifically mocking a zero `average_hohmann_speed_ms`.
    *   **Outputs/Side Effects**: Calls `main.main()` and asserts that a warning is printed regarding the fallback speed, and that `mock_save_travel_log` is called with the expected fallback speed (0.1% of C).

### Dependencies

*   `pytest`: For the testing framework and fixtures.
*   `unittest.mock.patch`, `MagicMock`, `call`: For mocking external dependencies and internal functions.
*   `datetime.datetime`, `timedelta`: For date and time calculations and assertions.
*   `math`: For mathematical operations like `sqrt` in relativistic calculations.
*   `sys`: Imported but not directly used in the provided snippet.
*   `main`: The module under test.
*   `constants.C_LIGHT_MPS`: A specific constant used in relativistic calculations.

---


## `tests/test_trajectory_planner.py`

This file contains a comprehensive suite of unit tests for the `TrajectoryPlanner` class, designed to verify its initialization logic and its `plan_trajectory` method for different transfer types (Hohmann and Direct Transfer) and data sources (dynamic ephemeris vs. static celestial data).

### Key Components:

*   **`mock_celestial_data_for_planner` (Fixture)**
    *   **Inputs**: Celestial body name (e.g., 'Sun', 'Earth').
    *   **Outputs/Side Effects**: Patches `trajectory_planner.celestial_data.get_celestial_body_data` to return predefined dictionaries containing planetary data (mass, radius, gravitational parameter, semi-major axis, orbital period).
*   **`mock_orbital_mechanics` (Fixture)**
    *   **Inputs**: Orbital parameters for celestial bodies.
    *   **Outputs/Side Effects**: Patches `trajectory_planner.orbital_mechanics.calculate_hohmann_transfer_delta_v`, `calculate_hohmann_transfer_time_of_flight`, and `calculate_lambert_transfer` to return mock success values (delta-V and time of flight) or raise specified errors.
*   **`mock_ephemeris_get_heliocentric_state` (Fixture)**
    *   **Inputs**: Body name, date.
    *   **Outputs/Side Effects**: Patches `trajectory_planner.ephemeris.get_heliocentric_state` to return mock heliocentric state data (distance from sun, angular position) for specific bodies and dates.
*   **`_parse_date_string` (Helper Function)**
    *   **Inputs**: A date string in '%Y-%m-%d' format.
    *   **Outputs/Side Effects**: Returns a `datetime` object.
*   **Test Categories**:
    *   **`TrajectoryPlanner.__init__`**: Tests successful initialization and error handling for missing/invalid Sun data.
    *   **`TrajectoryPlanner.plan_trajectory (Hohmann type)`**: Verifies Hohmann transfer calculations, handling of departure dates (prioritizing ephemeris, falling back to static data), input validation, and various error conditions (non-existent bodies, orbital mechanics failures).
    *   **`TrajectoryPlanner.plan_trajectory (Direct Transfer type)`**: Tests the Direct Transfer mechanism (using Lambert's problem), ensuring correct interaction with ephemeris data for angular positions, and handling of critical missing data or orbital mechanics errors.
    *   **`TrajectoryPlanner.plan_trajectory (Dispatching)`**: Checks default trajectory type behavior and validates handling of unsupported or invalid trajectory types.

### Dependencies:

*   `pytest`
*   `unittest.mock` (`patch`, `MagicMock`, `call`)
*   `datetime` (`timedelta`, `datetime`)
*   `math`
*   **Relative Imports**: `trajectory_planner`, `celestial_data`, `orbital_mechanics`, `constants`. (Note: `ephemeris` is implicitly patched via `trajectory_planner.ephemeris`).

---


## `trajectory_planner.py`

```markdown
## File Summary: trajectory_planner.py

This file defines a `TrajectoryPlanner` class, providing a high-level interface for planning interplanetary trajectories by orchestrating calls to underlying orbital mechanics and ephemeris modules. It calculates trajectory details such as total delta-v and travel time for various transfer types, considering dynamic orbital positions based on a departure date.

### Key Components:

*   **`TrajectoryPlanner` Class**:
    *   **`__init__(self)`**:
        *   **Inputs**: None, but fetches Sun data from `celestial_data`.
        *   **Outputs**: Initializes `self.mu_sun` (Sun's gravitational parameter). Raises errors if Sun data is invalid or missing.
    *   **`_plan_hohmann_trajectory(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime)`**:
        *   **Inputs**: Departure body name, arrival body name (strings), and a departure date (datetime object).
        *   **Outputs**: A dictionary with details for a Hohmann transfer, including total Delta-V, travel time, and success status.
    *   **`_plan_direct_transfer(self, departure_body_name: str, arrival_body_name: str, departure_date: datetime)`**:
        *   **Inputs**: Departure body name, arrival body name (strings), and a departure date (datetime object).
        *   **Outputs**: A dictionary with details for a direct transfer (via Lambert's problem), including total Delta-V, travel time, and success status, obtained by iterating through potential flight times.
    *   **`plan_trajectory(self, departure_body_name: str, arrival_body_name: str, trajectory_type: str = 'Hohmann', **kwargs)`**:
        *   **Inputs**: Departure body name, arrival body name (strings), trajectory type (string, 'Hohmann' or 'Direct'), and `departure_date` (string 'YYYY-MM-DD') via kwargs.
        *   **Outputs**: A dictionary containing the planned trajectory details or an error message, dispatching to the appropriate internal planning method.

*   **`if __name__ == '__main__':` block**:
    *   **Inputs**: Hardcoded example calls to `plan_trajectory` with various valid and invalid parameters.
    *   **Outputs**: Prints the results of trajectory planning attempts (success or error messages) to the console.

### Dependencies:

*   `math`
*   `datetime`, `timedelta` (from `datetime` module)
*   `orbital_mechanics` (local custom module)
*   `celestial_data` (local custom module)
*   `ephemeris` (local custom module)
```

---


## `travel_logger.py`

```markdown
## travel_logger.py

### Purpose
This file provides a utility function to log detailed space travel calculation data, including origin, destination, speed, travel time, delta-v, fuel mass, and transfer type, into a JSON file named `travel_log.json`. It ensures the log file is properly managed, handling cases where it might not exist, be empty, or be malformed.

### Key Components

*   **`save_travel_log` function**:
    *   **Inputs**:
        *   `source_planet` (str): Origin celestial body.
        *   `destination_planet` (str): Destination celestial body.
        *   `speed` (float): Spacecraft travel speed.
        *   `travel_time` (float): Estimated travel time.
        *   `delta_v_required` (float): Required change in velocity.
        *   `fuel_mass_needed` (float): Estimated fuel mass.
        *   `transfer_type` (str): Type of orbital transfer.
    *   **Outputs/Side Effects**:
        *   Creates or updates `travel_log.json` by appending a new dictionary entry containing the provided travel details along with a timestamp.
        *   Prints warning messages to the console if the `travel_log.json` file is found to be corrupted, malformed, or has unexpected content.

### Dependencies
*   `json`: For encoding and decoding JSON data to/from the log file.
*   `datetime`: For generating ISO-formatted timestamps for each log entry.
*   `os`: For checking the existence of the log file.
```

---
